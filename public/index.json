[{"content":"复习数据结构二叉树 什么是二叉树？ 二叉树（binary tree）是一种非线性数据结构，代表“祖先”与“后代”之间的派生关系，体现了“一分为二”的分治逻辑。与链表类似，二叉树的基本单元是节点，每个节点包含值、左子节点引用和右子节点引用。每个节点都有两个引用（指针），分别指向左子节点（left-child node）和右子节点（right-child node），该节点被称为这两个子节点的父节点（parent node）。当给定一个二叉树的节点时，我们将该节点的左子节点及其以下节点形成的树称为该节点的左子树（left subtree），同理可得右子树（right subtree）。\n1/* 二叉树节点类 */ 2class TreeNode { 3 int val; // 节点值 4 TreeNode left; // 左子节点引用 5 TreeNode right; // 右子节点引用 6 TreeNode(int x) { val = x; } 7} 二叉树常见术语 根节点（root node）：位于二叉树顶层的节点，没有父节点。 叶节点（leaf node）：没有子节点的节点，其两个指针均指向 None 。 边（edge）：连接两个节点的线段，即节点引用（指针）。 节点所在的层（level）：从顶至底递增，根节点所在层为 1 。 节点的度（degree）：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。 二叉树的高度（height）：从根节点到最远叶节点所经过的边的数量。 节点的深度（depth）：从根节点到该节点所经过的边的数量。 节点的高度（height）：从距离该节点最远的叶节点到该节点所经过的边的数量。 ","permalink":"http://localhost:1313/posts/%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A0%91/","summary":"\u003ch1 id=\"复习数据结构二叉树\"\u003e复习数据结构二叉树\u003c/h1\u003e\n\u003ch2 id=\"什么是二叉树\"\u003e什么是二叉树？\u003c/h2\u003e\n\u003cp\u003e二叉树（binary tree）是一种非线性数据结构，代表“祖先”与“后代”之间的派生关系，体现了“一分为二”的分治逻辑。与链表类似，二叉树的基本单元是节点，每个节点包含值、左子节点引用和右子节点引用。每个节点都有两个引用（指针），分别指向左子节点（left-child node）和右子节点（right-child node），该节点被称为这两个子节点的父节点（parent node）。当给定一个二叉树的节点时，我们将该节点的左子节点及其以下节点形成的树称为该节点的左子树（left subtree），同理可得右子树（right subtree）。\u003c/p\u003e","title":"复习数据结构二叉树"},{"content":"一、Mysql存储引擎 1.Mysql的体系结构 连接层 服务层 引擎层 存储层 2.存储引擎介绍 存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型 。我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎(InnoDB)。\n2.1InnoDB 1).介绍\nInnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5之后，InnoDB是默认的MySQL存储引擎。\n2).特点\n●DML操作遵循ACID模型，支持事务；\n●行锁，提高并发访问性能；\n●支持外键FOREIGN KEY约束，保证数据的完整性和正确性；\n3).文件\n参数：innodb_file_per_table\nshow variables like \u0026#39;innodb_file_per_table\u0026#39;; 如果该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件。，存储该表的表结构（frm-早期的 、sdi-新版的）、数据和索引。\nshow variables like \u0026#39;%datadir%\u0026#39;; 使用上面的命令查看自己表数据存储位置\n4)*逻辑存储结构*\n表空间: InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以包含多个Segment段。 段:表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。 区:区是表空间的单元结构，每个区的大小为1M。默认情况下， InnoDB存储引擎页大小为16K，即一个区中一共有64个连续的页。 页:页是组成区的最小单元，页也是InnoDB存储引擎磁盘管理的最小单元 ，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB存储引擎每次从磁盘申请 4-5个区。 行: InnoDB存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段(后面会详细介绍)。 2.2 MyISAM（被） 1).介绍\nMyISAM是MySQL早期的默认存储引擎。\n2).特点\n不支持事务，不支持外键\n支持表锁，不支持行锁\n访问速度快\n2.3Memory 1).介绍\nMemory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。\n2).特点\n存放在内存中\nhash索引（默认）\n2.4三种索引的区别 二、索引 索引概述 索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。\n无索引和有索引的情况下 假如我们要执行的SQL语句为 ： select* from user where age= 45;\n在无索引的情况下会对全表进行扫描效率很低\n在有索引时我们可以根据这个表建立索引，一般索引都是B+tree，然后会根据age进行查找\n优势 劣势 提高数据检索的效率，降低数据库IO成本 索引列也要占用空间 通过索引|列对数据进行排序，降低 、数据排序的成本，降低CPU的消 耗。 索引大大提高了查询效率，同时却也降低更新表的速度 如对表进行INSERT、UPDATE、DELETE时，效率降低 索引结构 索引结构 描述 B+Tree索引 最常见的索引类型，大部分引擎都支持 B+树索引 Hash索引 底层数据结构是用哈希表实现的,只有精确匹配索引列的查询才有效,不支持范围查询 R-tree(空间索引） 空间索引|是MyISAM引|擎的一个特殊索引类型，主要用于地理空间数据类 型，通常使用较少 Full-text(全文索引) 是一种通过建立倒排索引，快速匹配文档的方式。类似于 Lucene, Solr,ES 上述是MySQL中所支持的所有的索引结构，接下来，我们再来看看不同的存储引擎对于索引结构的支持情况。\n索引分类 在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。\n索引基础分类 分类 含义 特点 关键字 主键索引 针对于表中主键创建的索引 默认自动创建,只能有一个 PRIMARY 唯一索引 避免同一个表中某数据列中的值重复 可以有多个 UNIQUE 常规索引 快速定位特定数据 可以有多个 全文索引 全文索引查找的是文本中的关键词，而不是比较索引中的值 可以有多个 FULLTEXT 聚集索引\u0026amp;二级索引 而在在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：\n分类 含义 特点 聚集索引(ClusteredIndex) 将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据 必须有,而且只有一个 二级索引(SecondaryIndex) 将数据与索引分开存储，索引结构的叶子节点关 可以存在多个 聚集索引选取规则:\n如果存在主键，主键索引就是聚集索引。 如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。 接下来，我们来分析一下，当我们执行如下的SQL语句时，具体的查找过程是什么样子的。\n具体过程如下:\n①.由于是根据name字段进行查询，所以先根据name=\u0026lsquo;Arm\u0026rsquo;到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm对应的主键值 10。\n②.由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到10对应的行row。\n③.最终拿到这一行的数据，直接返回即可。\n回表查询： 这种先到二级索引中查找数据，找到主键值, 然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询\n索引语法 1）创建索引\nCREATE [UNIQUE | FULLTEXT] INDEX index_name NO table_name(index_col_name,....); 查看索引 SHOW INDEX FROM table_name; 3)删除索引\nDROP INDEX index_name NO table_name; 三、SQL性能分析 3.1SQL执行频率 MySQL客户端连接成功后，通过 show[session|global] status命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：\n-- session 是查看当前会话； -- global 是查询全局数据； SHOW GLOBAL STATUS LIKE \u0026#39;COM_______\u0026#39;; 通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。如果是以增删改为主，我们可以考虑不对其进行索引的优化。如果是以查询为主，那么就要考虑对数据库的索引进行优化了。\n3.2慢查询日志 慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。\nMySQL的慢查询日志默认没有开启，我们可以查看一下系统变量 slow_query_log。\nshow variables like \u0026#39;%quer%\u0026#39;; 在windos下开启慢查询 临时开启慢查询（重启MySQL后就会失效）\nset global slow_query_log=\u0026#39;ON\u0026#39;; --设置慢查询日志存放的位置 set global slow_query_log_file=\u0026#39;D:\\\\home\\\\mysql.log\u0026#39;; 永久开启慢查询（mysql版本5.7.30）\n找到mysql的安装目录，找到my.ini文件夹在[mysqld]处加入以下代码开启慢查询，永久有效。\n#存储位置 datadir=D:/soft/mysql-5.30/Data #开启慢查询 slow-query-log=1 #D:/soft/mysql-5.30/Data/HJH-slow.log 慢查询日志文件存储位置 slow_query_log_file=\u0026#34;HJH-slow.log\u0026#34; #慢查询判断时间 long_query_time=10 在Ubuntu中开启慢查询 //TODO\nprofile详情 show profiles能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前MySQL是否支持profile操作： -- 查看数据库是否支持profile SELECT @@have_profiling; -- 开启profile SET [session | global]profiling = 1; 开启profiling后就能使用profiling相关命令来查询执行过的SQL语句\n执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时：\n-- 查看每一条SQL的耗时基本情况 show profiles; -- 查看指定query_id的SQL语句各个阶段的耗时情况 show profile for query query_id; -- 查看指定query_id的SQL语句CPU的使用情况 show profile cpu for query query_id; explain EXPLAIN或者 DESC命令获取 MySQL如何执行 SELECT语句的信息，包括在 SELECT语句执行过程中表如何连接和连接的顺序。\n-- 直接在select语句前加上关键字 explain/desc EXPLAIN SELECT 字段列表 FROM 表明 WHERE 条件; Explain执行计划中各个字段的含义:\n字段 含义 id select查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下；id不同，值越大，越先执行)。 select_type 表示 SELECT的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等 type 表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、 index、all 。 possible_key 显示可能应用在这张表上的索引，一个或多个。 key 实际使用的索引，如果为NULL，则没有使用索引。 key_len 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好 。 rows MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。 filtered 表示返回结果的行数占需读取行数的百分比， filtered的值越大越好。 Extra Using where: Using Index 查找使用了索引，但是需要的数据都在索引列表中找到，所以不需要回表查询 。Using index condition:查找使用了索引，但是需要回表查询数据 五、索引的使用 最左前缀法则 使用联合索引时要遵守最左前缀法则。最左前缀法则是指在查询索引时从索引的最左列开始，并且不跳过索引中的列。如果跳过某一列，后面的字段索引失效。\ntb_user表\ncreate table tb_user( id int primary key auto_increment comment \u0026#39;主键\u0026#39;, name varchar(50) not null comment \u0026#39;用户名\u0026#39;, phone varchar(11) not null comment \u0026#39;手机号\u0026#39;, email varchar(100) comment \u0026#39;邮箱\u0026#39;, profession varchar(11) comment \u0026#39;专业\u0026#39;, age tinyint unsigned comment \u0026#39;年龄\u0026#39;, gender char(1) comment \u0026#39;性别 , 1: 男, 2: 女\u0026#39;, status char(1) comment \u0026#39;状态\u0026#39;, createtime datetime comment \u0026#39;创建时间\u0026#39; ) comment \u0026#39;系统用户表\u0026#39;; INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;吕布\u0026#39;, \u0026#39;17799990000\u0026#39;, \u0026#39;lvbu666@163.com\u0026#39;, \u0026#39;软件工程\u0026#39;, 23, \u0026#39;1\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;2001-02-02 00:00:00\u0026#39;); INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;曹操\u0026#39;, \u0026#39;17799990001\u0026#39;, \u0026#39;caocao666@qq.com\u0026#39;, \u0026#39;通讯工程\u0026#39;, 33, \u0026#39;1\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;2001-03-05 00:00:00\u0026#39;); INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;赵云\u0026#39;, \u0026#39;17799990002\u0026#39;, \u0026#39;17799990@139.com\u0026#39;, \u0026#39;英语\u0026#39;, 34, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;2002-03-02 00:00:00\u0026#39;); INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;孙悟空\u0026#39;, \u0026#39;17799990003\u0026#39;, \u0026#39;17799990@sina.com\u0026#39;, \u0026#39;工程造价\u0026#39;, 54, \u0026#39;1\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;2001-07-02 00:00:00\u0026#39;); INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;花木兰\u0026#39;, \u0026#39;17799990004\u0026#39;, \u0026#39;19980729@sina.com\u0026#39;, \u0026#39;软件工程\u0026#39;, 23, \u0026#39;2\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2001-04-22 00:00:00\u0026#39;); INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;大乔\u0026#39;, \u0026#39;17799990005\u0026#39;, \u0026#39;daqiao666@sina.com\u0026#39;, \u0026#39;舞蹈\u0026#39;, 22, \u0026#39;2\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;2001-02-07 00:00:00\u0026#39;); INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;露娜\u0026#39;, \u0026#39;17799990006\u0026#39;, \u0026#39;luna_love@sina.com\u0026#39;, \u0026#39;应用数学\u0026#39;, 24, \u0026#39;2\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;2001-02-08 00:00:00\u0026#39;); INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;程咬金\u0026#39;, \u0026#39;17799990007\u0026#39;, \u0026#39;chengyaojin@163.com\u0026#39;, \u0026#39;化工\u0026#39;, 38, \u0026#39;1\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;2001-05-23 00:00:00\u0026#39;); INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;项羽\u0026#39;, \u0026#39;17799990008\u0026#39;, \u0026#39;xiaoyu666@qq.com\u0026#39;, \u0026#39;金属材料\u0026#39;, 43, \u0026#39;1\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;2001-09-18 00:00:00\u0026#39;); INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;白起\u0026#39;, \u0026#39;17799990009\u0026#39;, \u0026#39;baiqi666@sina.com\u0026#39;, \u0026#39;机械工程及其自动化\u0026#39;, 27, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;2001-08-16 00:00:00\u0026#39;); INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;韩信\u0026#39;, \u0026#39;17799990010\u0026#39;, \u0026#39;hanxin520@163.com\u0026#39;, \u0026#39;无机非金属材料工程\u0026#39;, 27, \u0026#39;1\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;2001-06-12 00:00:00\u0026#39;); INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;荆轲\u0026#39;, \u0026#39;17799990011\u0026#39;, \u0026#39;jingke123@163.com\u0026#39;, \u0026#39;会计\u0026#39;, 29, \u0026#39;1\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;2001-05-11 00:00:00\u0026#39;); INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;兰陵王\u0026#39;, \u0026#39;17799990012\u0026#39;, \u0026#39;lanlinwang666@126.com\u0026#39;, \u0026#39;工程造价\u0026#39;, 44, \u0026#39;1\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2001-04-09 00:00:00\u0026#39;); INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;狂铁\u0026#39;, \u0026#39;17799990013\u0026#39;, \u0026#39;kuangtie@sina.com\u0026#39;, \u0026#39;应用数学\u0026#39;, 43, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;2001-04-10 00:00:00\u0026#39;); INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;貂蝉\u0026#39;, \u0026#39;17799990014\u0026#39;, \u0026#39;84958948374@qq.com\u0026#39;, \u0026#39;软件工程\u0026#39;, 40, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;2001-02-12 00:00:00\u0026#39;); INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;妲己\u0026#39;, \u0026#39;17799990015\u0026#39;, \u0026#39;2783238293@qq.com\u0026#39;, \u0026#39;软件工程\u0026#39;, 31, \u0026#39;2\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;2001-01-30 00:00:00\u0026#39;); INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;芈月\u0026#39;, \u0026#39;17799990016\u0026#39;, \u0026#39;xiaomin2001@sina.com\u0026#39;, \u0026#39;工业经济\u0026#39;, 35, \u0026#39;2\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;2000-05-03 00:00:00\u0026#39;); INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;嬴政\u0026#39;, \u0026#39;17799990017\u0026#39;, \u0026#39;8839434342@qq.com\u0026#39;, \u0026#39;化工\u0026#39;, 38, \u0026#39;1\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2001-08-08 00:00:00\u0026#39;); INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;狄仁杰\u0026#39;, \u0026#39;17799990018\u0026#39;, \u0026#39;jujiamlm8166@163.com\u0026#39;, \u0026#39;国际贸易\u0026#39;, 30, \u0026#39;1\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;2007-03-12 00:00:00\u0026#39;); INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;安琪拉\u0026#39;, \u0026#39;17799990019\u0026#39;, \u0026#39;jdodm1h@126.com\u0026#39;, \u0026#39;城市规划\u0026#39;, 51, \u0026#39;2\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;2001-08-15 00:00:00\u0026#39;); INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;典韦\u0026#39;, \u0026#39;17799990020\u0026#39;, \u0026#39;ycaunanjian@163.com\u0026#39;, \u0026#39;城市规划\u0026#39;, 52, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;2000-04-12 00:00:00\u0026#39;); INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;廉颇\u0026#39;, \u0026#39;17799990021\u0026#39;, \u0026#39;lianpo321@126.com\u0026#39;, \u0026#39;土木工程\u0026#39;, 19, \u0026#39;1\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;2002-07-18 00:00:00\u0026#39;); INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;后羿\u0026#39;, \u0026#39;17799990022\u0026#39;, \u0026#39;altycj2000@139.com\u0026#39;, \u0026#39;城市园林\u0026#39;, 20, \u0026#39;1\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;2002-03-10 00:00:00\u0026#39;); INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;姜子牙\u0026#39;, \u0026#39;17799990023\u0026#39;, \u0026#39;37483844@qq.com\u0026#39;, \u0026#39;工程造价\u0026#39;, 29, \u0026#39;1\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;2003-05-26 00:00:00\u0026#39;); 在 tb_user表中，有一个联合索引，这个联合索引涉及到三个字段，顺序分别为：profession， age，status。\n对于最左前缀法则指的是，查询时，最左边的列，也就是profession必须存在，否则索引全部失效。\n从图中可以看出只要有profession存在就会使用索引，当profession不存在即使使用后面的属性也不会触发索引。\n思考题： 当执行SQL语句: explain select * from tb_user where age = 3 and status=\u0026lsquo;0’ and profession=\u0026lsquo;软件工程\u0026rsquo;;时，是否满足最左前缀法则，走不走 上述的联合索引，索引长度？\n很显然时走的，最左前缀法则中指的最最左边的列，是指在查询时，联合索引的最左边的字段（就是第一个字段）必须存在，与我们编写SQL时。条件的顺序无关。\n范围查询 联合索引中，出现范围查询(\u0026gt;,\u0026lt;)，范围查询右侧的列索引失效。\n在使用范围查询时有效字段是38，但是在不使用时有效字段是42，说明在使用范围查询时有字段失效了。\n所以在业务允许的情况下，尽可能的使用类似的\u0026gt;=或\u0026lt;=这类的范围查询。\n范围失效的情况 索引列运算 不要在索引列上进行运算操作，索引将失效。\n字符串不加引号 不要在索引列上进行运算操作，索引将失效。\n模糊查询使用头部模糊查询，索引失效 如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。\nor连接条件 用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。\n-数据分布影响。\n如果MySQL评估使用索引比全表更慢，则不使用索引。\nSQL提示 SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的\n1). use index ：建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进行评估）。\nexplain select * from tb_user use index(idx_user_pro) where profession=\u0026#39;软件工程\u0026#39; 2). ignore index ：忽略指定的索引。\nexplain select * from tb_user ignore index(idx_user_pro) where profession=\u0026#39;软件工程\u0026#39; 3). force index ：强制使用索引。\nexplain select * from tb_user ignore index(idx_user_pro) where profession=\u0026#39;软件工程\u0026#39; 覆盖索引 尽量使用覆盖索引，减少select*。那么什么是覆盖索引呢？覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。\nB.执行SQL: select * from tb_user where id =2;\n根据id查询，直接走聚集索引查询一次索引扫描，直接返回数据，性能高。\nc.执行SQL: select id ,name from tb_user where name =\u0026lsquo;Arm\u0026rsquo;;\n根据name字段查询辅助索引，id和name在name的二级索引中都是可以直接获取到的，所以不需要回表查询，性能高。\nd.执行SQL:select id ,name ,gender from tb_user where name =\u0026lsquo;Arm\u0026rsquo;;\n由于在name的二级索引中，不包含gender，所以，需要两次索引扫描，也就是需要回表查询，性能相对较差一点。\n前缀索引 当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。\n1).语法\ncreate index idx_xxxx on table_name(colum(n)); 示例\n在tb_user的表的email字段，建立长度未5的前缀索引。\ncreate index idx_email_5 on tb_user(email(5)); 2)查询流程\n单列索引和联合索引 单列索引：即一个索引只包含单个列。\n联合索引：即一个索引包含了多个列。\n在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。\n索引设计原则 1).针对于数据量较大，且查询比较频繁的表建立索引。\n2).针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。\n3).尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。\n4).如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。\n5).尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。\n6).要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。\n7).如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。\n","permalink":"http://localhost:1313/posts/mysql%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D/","summary":"\u003ch1 id=\"一mysql存储引擎\"\u003e\u003cstrong\u003e一、Mysql存储引擎\u003c/strong\u003e\u003c/h1\u003e\n\u003ch2 id=\"1mysql的体系结构\"\u003e\u003cstrong\u003e1.Mysql的体系结构\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.postimg.cc/MpV3xV4W/screenshot-16.png\" alt=\"\"  /\u003e\r\n\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e连接层\u003c/li\u003e\n\u003cli\u003e服务层\u003c/li\u003e\n\u003cli\u003e引擎层\u003c/li\u003e\n\u003cli\u003e存储层\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"2存储引擎介绍\"\u003e\u003cstrong\u003e2.存储引擎介绍\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003e存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是基于库的，\u003ccode\u003e所以存储引擎也可被称为表类型\u003c/code\u003e 。我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎(InnoDB)。\u003c/p\u003e","title":"Mysql存储引擎"},{"content":"事务 事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。\n使用到的关键字 set autocommit=0; start transaction; commit; rollback; savepoint 断点 commit to 断点 rollback to 断点 事务四大特性 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据改变就是永久的 并发事务问题 1） 脏读：一个事务读到另一个事务还没有提交的数据\n比如B读取到了A未提交的数据。\n2） 不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称为不可重复读。\n事务A两次读取同一条记录，但是读取到的数据却是不一样的。\n3） 幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据\n不可重复读和幻读的区别\n不可重复读是读取了其他事务更改的数据 -\u0026gt;update 幻读是读取了其他事务新增的数据 -\u0026gt;insert和delete\n事务的隔离级别 为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。\n数据库事务的隔离级别有4个，由低到高依次为Read uncommitted 、Read committed 、Repeatable read 、Serializable ，这四个级别可以逐个解决脏读 、不可重复读 、幻读 这几类问题。\nMySql默认REPEATABLE_READ\n隔离级别 脏读 不可重复读 幻读 Read uncommitted(读未提交) Y Y Y Read committed(读以提交) N Y Y Repeatable Read(可重复读) N N Y Serializable N N N 查看事务隔离级别 SELECT @@TRANSACTION_ISOLATION; 设置事务隔离级别 SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL { READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE } ","permalink":"http://localhost:1313/posts/mysql%E4%BA%8B%E5%8A%A1/","summary":"\u003ch1 id=\"事务\"\u003e事务\u003c/h1\u003e\n\u003cp\u003e事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。\u003c/p\u003e","title":"Mysql事务"},{"content":"Mysql常用函数 聚合函数 函数 功能 count 统计数量 max 最大值 min 最小值 avg 平均值 sum 求和 字符串函数 函数 功能 CONCAT(S1,S2,\u0026hellip;Sn) 字符串拼接，将S1，S2，\u0026hellip; Sn拼接成一个字符串 LOWER(str) 将字符串str全部转为小写 UPPER(str) 将字符串str全部转为大写 LPAD(str,n,pad) 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 RPAD(str,n,pad) 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 TRIM(str) 去掉字符串头部和尾部的空格 SUBSTRING(str,start,len) 返回从字符串str从start位置起的len个长度的字符串 数值函数 函数 功能 CEIL(x) 向上取整 FLOOR(x) 向下取整 MOD(x,y) 返回x/y的模 RAND() 返回0~1内的随机数 ROUND(x,y) 求参数x的四舍五入的值，保留y位小数 例题：\n通过数据库的函数，生成一个六位数的随机验证码。\n1 select lpad(round(rand()*1000000,0),6,\u0026#39;0\u0026#39;) 日期函数 函数 功能 CURDATE() 返回当前日期 CURTIME() 返回当前时间 NOW() 返回当前日期和时间 YEAR(date) 获取指定date的年份 MONTH(date) 获取指定date的月份 DAY(date) 获取指定date的日期 DATE_ADD(date, INTERVAL exprtype) 返回一个日期/时间值加上一个时间间隔expr后的时间值 DATEDIFF(date1,date2) 返回起始时间date1 和 结束时间date2之间的天数 例题：\n查询所有员工的入职天数，并根据入职天数倒序排序\n1 select name, datediff(curdate(), entrydate) as \u0026#39;entrydays\u0026#39; from emp order by 2 entrydays desc; 流程函数 函数 功能 IF(value , t , f) 如果value为true，则返回t，否则返回f IFNULL(value1 , value2) 如果value1不为空，返回value1，否则返回value2 CASE WHEN [ val1 ] THEN [res1] \u0026hellip;ELSE [ default ] END 如果val1为true，返回res1，\u0026hellip; 否则返回default默认值 CASE [ expr ] WHEN [ val1 ] THEN[res1] \u0026hellip; ELSE [ default ] END 如果expr的值等于val1，返回res1，\u0026hellip; 否则返回default默认值 ","permalink":"http://localhost:1313/posts/mysql%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/","summary":"\u003ch1 id=\"mysql常用函数\"\u003eMysql常用函数\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"https://i.postimg.cc/cJQ332yQ/screenshot-12.png\" /\u003e\u003cbr\u003e\u003c/p\u003e\n\u003ch2 id=\"聚合函数\"\u003e\u003cstrong\u003e聚合函数\u003c/strong\u003e\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: left\"\u003e函数\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e功能\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003ecount\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e统计数量\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003emax\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e最大值\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003emin\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e最小值\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eavg\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e平均值\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003esum\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e求和\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"字符串函数\"\u003e\u003cstrong\u003e字符串函数\u003c/strong\u003e\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: left\"\u003e函数\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e功能\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eCONCAT(S1,S2,\u0026hellip;Sn)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e字符串拼接，将S1，S2，\u0026hellip; Sn拼接成一个字符串\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eLOWER(str)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e将字符串str全部转为小写\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eUPPER(str)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e将字符串str全部转为大写\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eLPAD(str,n,pad)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e左填充，用字符串pad对str的左边进行填充，达到n个字符串长度\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eRPAD(str,n,pad)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e右填充，用字符串pad对str的右边进行填充，达到n个字符串长度\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eTRIM(str)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e去掉字符串头部和尾部的空格\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eSUBSTRING(str,start,len)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e返回从字符串str从start位置起的len个长度的字符串\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"数值函数\"\u003e\u003cstrong\u003e数值函数\u003c/strong\u003e\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: left\"\u003e函数\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e功能\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eCEIL(x)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e向上取整\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eFLOOR(x)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e向下取整\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eMOD(x,y)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e返回x/y的模\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eRAND()\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e返回0~1内的随机数\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eROUND(x,y)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e求参数x的四舍五入的值，保留y位小数\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e例题：\u003cbr\u003e\n通过数据库的函数，生成一个六位数的随机验证码。\u003c/p\u003e","title":"Mysql常用函数"},{"content":"配置硬件加速 使用SDK 管理器安装 1.选择Tools\u0026gt;SDK Manger\n2.点击 SDK Tools 标签页，然后选择 Android Emulator Hypervisor Driver\n3.点击 OK，以下载并安装 Android Emulator Hypervisor Driver。\n4.安装后，返回命令行中使用以下命令，确认驱动程序能正常运行：\n1sc query aehd 如何出现错误先尝试关闭 Hyper-V 禁用Hyper-V 在控制面板中禁用 Hyper-V 1.在dos窗口或者powershell中运行命令\n1control 2.点击程序\n3.点击启用或者关闭Windos功能\n4.展开 Hyper-V，展开 Hyper-V 平台，然后清除“Hyper-V 虚拟机监控程序”复选框。 在PowerShell 中禁用 Hyper-V 1.提升PowerShell 窗口的权限为管理员\n1 sudo 2.运行以下命令\n1Disable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V-Hypervisor 参考文献\n虚拟化应用程序无法与 Hyper-V、Device Guard 和 Credential Guard 协同工作\n","permalink":"http://localhost:1313/posts/stop-hyper-v/","summary":"\u003ch1 id=\"配置硬件加速\"\u003e配置硬件加速\u003c/h1\u003e\n\u003ch2 id=\"使用sdk-管理器安装\"\u003e使用SDK 管理器安装\u003c/h2\u003e\n\u003cp\u003e1.选择Tools\u0026gt;SDK Manger\u003cbr\u003e\n\u003cimg src=\"https://i.postimg.cc/g2zgzhDN/screenshot-9.png\" /\u003e\u003c/p\u003e","title":"Stop Hyper V"},{"content":"java集合简介 一、集合基本的关系结构 Collection 接口的接口 对象的集合（单列集合）\nList 接口：元素按进入先后有序保存，可重复 LinkedList 接口实现类， 链表， 插入删除， 没有同步， 线程不安全 ArrayList 接口实现类， 数组， 随机访问， 没有同步， 线程不安全 Vector 接口实现类 数组， 同步， 线程安全 Stack 是Vector类的实现类 Set 接口： 仅接收一次，不可重复，并做内部排序 HashSet 使用hash表（数组）存储元素 LinkedHashSet 链表维护元素的插入次序 TreeSet 底层实现为二叉树，元素排好序 Map 接口 键值对的集合 （双列集合）\nHashtable 接口实现类， 同步， 线程安全 HashMap 接口实现类 ，没有同步， 线程不安全 LinkedHashMap 双向链表和哈希表实现 WeakHashMap TreeMap 红黑树对所有的key进行排序 IdentifyHashMap 二、Collection接口及方法 2.1 添加 （1）add(E obj)：添加元素对象到当前集合中\n（2）addAll(Collection other)：添加other集合中的所有元素对象到当前集合中，即this = this ∪ other\n2.2 判断 （3）int size()：获取当前集合中实际存储的元素个数\n（4）boolean isEmpty()：判断当前集合是否为空集合\n（5）boolean contains(Object obj)：判断当前集合中是否存在一个与obj对象equals返回true的元素\n（6）boolean containsAll(Collection coll)：判断coll集合中的元素是否在当前集合中都存在。即coll集合是否是当前集合的“子集”\n（7）boolean equals(Object obj)：判断当前集合与obj是否相等\n2.3 删除 （8）void clear()：清空集合元素\n（9） boolean remove(Object obj) ：从当前集合中删除第一个找到的与obj对象equals返回true的元素。\n（10）boolean removeAll(Collection coll)：从当前集合中删除所有与coll集合中相同的元素。即this = this - this ∩ coll （11）boolean retainAll(Collection coll)：从当前集合中删除两个集合中不同的元素，使得当前集合仅保留与coll集合中的元素相同的元素，即当前集合中仅保留两个集合的交集，即this = this ∩ coll；\n2.4其他 （12）Object[] toArray()：返回包含当前集合中所有元素的数组\n（13）hashCode()：获取集合对象的哈希值\n（14）iterator()：返回迭代器对象，用于集合遍历\n三、List集合 3.1 List接口特点 List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。\nJDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。\n3.2 List接口方法 List除了从Collection集合继承的方法外，List 集合里添加了一些根据索引来操作集合元素的方法。\n插入元素 void add(int index,Object ele); 在哦index位置插入ele元素 boolean add(int index ,Collection eles);从index位置开始将eles中的所有元素添加进来 获取元素 Object get(int inedx);获取指定index位置的元素 List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合 获取元素索引 int indexOf(Object obj):返回obj在集合中首次出现的位置 int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置 删除和替换元素 Object remove(int index):移除指定index位置的元素，并返回此元素 Object set(int index, Object ele):设置指定index位置的元素为ele 3.3 List接口主要实现类：ArrayList ArrayList 是 List 接口的主要实现类 本质上，ArrayList是对象引用的一个”变长”数组 Arrays.asList(…) 方法返回的 List 集合，既不是 ArrayList 实例，也不是 Vector 实例。 Arrays.asList(…) 返回值是一个固定长度的 List 集合 3.4 List的实现类之二：LinkedList 对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高。这是由底层采用链表（双向链表）结构存储数据决定的。 特有方法 void addFirst(Object obj) void addLast(Object obj) Object getFirst() Object getLast() Object removeFirst() Object removeLast() 3.5 List的实现类之三：Vector Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的。 在各种List中，最好把ArrayList作为默认选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用。 四、Set集合 4.1 Set接口概述 Set接口是Collection的子接口，Set接口相较于Collection接口没有提供额外的方法 Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个 Set 集合中，则添加操作失败。 Set集合支持的遍历方式和Collection集合一样：foreach和Iterator。 Set的常用实现类有：HashSet、TreeSet、LinkedHashSet。 4.2 Set主要实现类：HashSet HashSet 是 Set 接口的主要实现类，大多数时候使用 Set 集合时都使用这个实现类。\nHashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存储、查找、删除性能。\nHashSet 具有以下特点：\n不能保证元素的排列顺序 HashSet 不是线程安全的 集合元素可以是 null HashSet 集合判断两个元素相等的标准：两个对象通过 hashCode() 方法得到的哈希值相等，并且两个对象的 equals() 方法返回值为true。\n对于存放在Set容器中的对象，对应的类一定要重写hashCode()和equals(Object obj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”。\nHashSet集合中元素的无序性，不等同于随机性。这里的无序性与元素的添加位置有关。具体来说：我们在添加每一个元素到数组中时，具体的存储位置是由元素的hashCode()调用后返回的hash值决定的。导致在数组中每个元素不是依次紧密存放的，表现出一定的无序性。\n4.3 Set实现类之二：LinkedHashSet LinkedHashSet 是 HashSet 的子类，不允许集合元素重复。\nLinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以添加顺序保存的。\nLinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。\n4.4 Set实现类之三：TreeSet TreeSet 是 SortedSet 接口的实现类，TreeSet 可以按照添加的元素的指定的属性的大小顺序进行遍历。 TreeSet底层使用红黑树结构存储数据 五 Map接口 现实生活与开发中，我们常会看到这样的一类集合：用户ID与账户信息、学生姓名与考试成绩、IP地址与主机名等，这种一一对应的关系，就称作映射。Java提供了专门的集合框架用来存储这种映射关系的对象，即java.util.Map接口。\n5.1 Map接口概述 Map与Collection并列存在。用于保存具有映射关系的数据：key-value\nCollection集合称为单列集合，元素是孤立存在的。 Map集合称为双列集合，元素是成对存在的。 Map 中的 key 和 value 都可以是任何引用类型的数据。但常用String类作为Map的“键”。\nMap接口的常用实现类：HashMap、LinkedHashMap、TreeMap和``Properties。其中，HashMap是 Map 接口使用频率最高`的实现类。\n5.2 Map接口的常用方法 添加、修改操作： Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中 void putAll(Map m):将m中的所有key-value对存放到当前map中 删除操作： Object remove(Object key)：移除指定key的key-value对，并返回value void clear()：清空当前map中的所有数据 元素查询的操作： Object get(Object key)：获取指定key对应的value boolean containsKey(Object key)：是否包含指定的key boolean containsValue(Object value)：是否包含指定的value int size()：返回map中key-value对的个数 boolean isEmpty()：判断当前map是否为空 boolean equals(Object obj)：判断当前map和参数对象obj是否相等 元视图操作的方法： Set keySet()：返回所有key构成的Set集合 Collection values()：返回所有value构成的Collection集合 Set entrySet()：返回所有key-value对构成的Set集合 5.3 Map的主要实现类：HashMap 5.3.1 HashMap概述 HashMap是 Map 接口使用频率最高的实现类。 HashMap是线程不安全的。允许添加 null 键和 null 值。 存储数据采用的哈希表结构，底层使用一维数组+单向链表+红黑树进行key-value数据的存储。与HashSet一样，元素的存取顺序不能保证一致。 HashMap 判断两个key相等的标准是：两个 key 的hashCode值相等，通过 equals() 方法返回 true。 HashMap 判断两个value相等的标准是：两个 value 通过 equals() 方法返回 true。 5.4 Map实现类之二：LinkedHashMap LinkedHashMap 是 HashMap 的子类 存储数据采用的哈希表结构+链表结构，在HashMap存储结构的基础上，使用了一对双向链表来记录添加元素的先后顺序，可以保证遍历元素时，与添加的顺序一致。 通过哈希表结构可以保证键的唯一、不重复，需要键所在类重写hashCode()方法、equals()方法。 5.5 Map实现类之三：TreeMap TreeMap存储 key-value 对时，需要根据 key-value 对进行排序。TreeMap 可以保证所有的 key-value 对处于有序状态。 TreeSet底层使用红黑树结构存储数据 TreeMap 的 Key 的排序： 自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException 定制排序：创建 TreeMap 时，构造器传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现 Comparable 接口 TreeMap判断两个key相等的标准：两个key通过compareTo()方法或者compare()方法返回0。 5.6 Map实现类之四：Hashtable Hashtable是Map接口的古老实现类，JDK1.0就提供了。不同于HashMap，Hashtable是线程安全的。 Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构（数组+单向链表），查询速度快。 与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序 Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。 与HashMap不同，Hashtable 不允许使用 null 作为 key 或 value。 5.7 Map实现类之五：Properties Properties 类是 Hashtable 的子类，该对象用于处理属性文件\n由于属性文件里的 key、value 都是字符串类型，所以 Properties 中要求 key 和 value 都是字符串类型\n存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法\n","permalink":"http://localhost:1313/posts/java%E9%9B%86%E5%90%88%E5%A4%8D%E4%B9%A0/","summary":"\u003ch1 id=\"java集合简介\"\u003ejava集合简介\u003c/h1\u003e\n\u003ch2 id=\"一集合基本的关系结构\"\u003e一、集合基本的关系结构\u003c/h2\u003e\n\u003cp\u003eCollection 接口的接口 对象的集合（单列集合）\u003c/p\u003e","title":"Java集合复习"},{"content":"MySQL的基本操作 1、查看所有的数据库\n1show datebases; 2、创建自己的数据库\n1create datebase 数据库名字; 3、使用自己的数据库\n1use 数据库名字; 说明：如果没有使用use语句，后面针对数据库的操作也没有加“数据名”的限定，那么会报“ERROR 1046 (3D000): No database selected”（没有选择数据库） 使用完use语句之后，如果接下来的SQL都是针对一个数据库操作的，那就不用重复use了，如果要针对另 一个数据库操作，那么要重新use。\n4、查看某个库的所有表格\n1show tables; #要求前面有use语句 2show tables from 数据库名; 5、创建新的表格\n1create table 表名称( 2字段名 数据类型, 3字段名 数据类型 4); 6、查看一个表的数据\n1select * from 数据库表名称; 7、添加一条记录\n1nsert into 表名称 values(值列表); 8、删除表格\n1drop table 表名称; 11、删除数据库\n1drop database 数据库名; ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003ch1 id=\"mysql的基本操作\"\u003eMySQL的基本操作\u003c/h1\u003e\n\u003cp\u003e1、查看所有的数据库\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-mysql\" data-lang=\"mysql\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eshow\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003edatebases\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e2、创建自己的数据库\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-mysql\" data-lang=\"mysql\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003ecreate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003edatebase\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"err\"\u003e数据库名字\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pr","title":"MySQL的基本操作"},{"content":"","permalink":"http://localhost:1313/java/%E6%B5%8B%E8%AF%95%E7%94%A8/","summary":"","title":"测试"},{"content":"这里就可以写一些关于的相关信息了。gt\n","permalink":"http://localhost:1313/about/","summary":"about","title":"关于"}]