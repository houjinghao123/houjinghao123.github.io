[{"content":"MySQL锁 1、概述 如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。\nMySQL中的锁，按照锁的粒度分，分为以下三类：\n全局锁：锁定数据库的所有表。 表级锁：每次操作锁住整张表。 行级锁：每次操作锁住对应的行数据。 2、全局锁 2.1介绍 全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。\n使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。\n在进行全库的逻辑备份时加锁是为了防止出现数据不一致问题，发生这种问题的原因如下：\n假设在数据库中存在这样三张表: tb_stock库存表，tb_order订单表，tb_orderlog订单日志表。\n在进行数据备份时，先备份了tb_stick库存表 然后接下来，在业务系统中，执行了下单操作，扣减库存，生成订单（更新tb_stock表，插入tb_order表）。 然后在执行备份tb_order表的逻辑。 业务中执行插入订单日志操作。 最后，又备份了tb_orderlog表。 此时备份出来的数据，是存在问题的。因为备份出来的数据，tb_stock表与tb_order表的数据不一致(有最新操作的订单信息,但是库存数没减)。\n在对数据库加上全局锁后\n对数据库进行进行逻辑备份之前，先对整个数据库加上全局锁，一旦加了全局锁之后，其他的DDL、DML全部都处于阻塞状态，但是可以执行DQL语句，也就是处于只读状态，而数据备份就是查询操作。那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性和完整性。\n2.2语法 1）加全局锁\n1flush table with read lock; 2）数据备份\n1mysqldump -uroot -p**** 要备份的数据库名 \u0026gt; 要备份到的地址/名字.sql 该方式时数据库自带的备份工具是直接在命令行窗口执行的\n3）释放锁\n1unlock tables; 2.3问题 数据库中加全局锁，是一个比较重的操作，存在以下问题：\n如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。 如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。 在InnoDB引擎中，我们可以在备份时加上参数\u0026ndash;single-transaction参数来完成不加锁的一致性数据备份。\n1mysqldump --single-transaction -uroot -p**** 要备份的数据库名 \u0026gt; 要备份到的地址/名字.sql 3表级锁 3.1介绍 表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。\n对于表级锁，主要分为以下三类\n表锁 元数据锁(meta data lock,MDL) 意向锁 3.2表锁 对于表锁，分为两类：\n表共享读锁（read lock） 表独占写锁（write lock） 语法：\n加锁：lock tables 表名\u0026hellip;read/write。 释放锁：unlock tables /断开客户端连接。 特点 :\n读锁 左侧为客户端一，对指定表加了读锁，不会影响右侧客户端二的读，但是会阻塞右侧客户端的写。\n写锁 左侧为客户端一，对指定表加了写锁，会阻塞右侧客户端的读和写。\n读锁不会堵塞其他客户端的读，但是会堵塞写。 写锁即会堵塞其他客户端的读，又会堵塞其他客户端换的写。\n3.3元数据锁 meta data lock,元数据锁，简写MDL。\nMDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性。\n这里的元数据，大家可以简单理解为就是一张表的表结构。也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。\n在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。\n常见的SQL操作时，所添加的元数据锁：\n对应SQL 锁类型 说明 lock tables xxx read/write SHARED_READ_ONLY/SHARED_NO_READ_WRITE select 、select\u0026hellip;lock in share mode SHARED_READ 与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥 insert 、update、delete、select\u0026hellip; forupdate SHARED_WRITE 与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥 alter table\u0026hellip; EXCLUSIVE 与其他的MDL都互斥 当执行SELECT、INSERT、UPDATE、DELETE等语句时，添加的是元数据共享锁（SHARED_READ/SHARED_WRITE），之间是兼容的。\n当执行SELECT语句时，添加的是元数据共享锁（SHARED_READ），会阻塞元数据排他锁（EXCLUSIVE），之间是互斥的。\n我们可以通过下面的SQL,来查看数据库中的元数据锁的情况:\n1select object_type,object_schema,object_name,lock_type,lock_duration from 2performance_schema.metadata_locks ; 如果是5.7版本的数据库需要手动开启metadata_locks锁记录(临时生效)\n1update performance_schema.setup_instruments set enabled = \u0026#39;YES\u0026#39;,timed=\u0026#39;YES\u0026#39; where name=\u0026#39;wait/lock/metadata/sql/mdl\u0026#39;; 永久生效在配置文件中加入以下内容\n1# 开启监控元数据锁 2performance-schema-instrument=\u0026#39;wait/lock/metadata/sql/mdl=ON\u0026#39; 当在不同的连接窗口上时EXCLUSIVE锁是和其他锁互斥的。如果在同一连接窗口则会强制提交事务。\n3.4意向锁 1）介绍\n为了避免DML在执行时，加的行锁与表锁冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据数据是否加锁，使用意向锁来减少表锁的检查。\n假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢，来通过示意图简单分析一下：\n首先客户端一，开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁。\n当客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，如果没有，则添加表锁，此时就会从第一行数据，检查到最后一行数据，效率较低。\n有了意向锁之后 : 客户端一，在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁。\n而其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了。\n2）分类\n意向共享锁（IS）:由语句select \u0026hellip; lock in share mode添加 。 与 表锁共享锁(read)兼容，与表锁排他锁(write)互斥。 意向排他锁 （IX）：由insert、update、delete、select\u0026hellip;for update添加。与表锁共享锁和排他锁都互斥，意向锁之间不会互斥。 一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。\n可以通过以下SQL，查看意向锁及行锁的加锁情况：（在Mysql8.0中能正常使用）\n1select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks; 四、行级锁 4.1介绍 行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。\nInnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：\n行锁（Record Lock）: 锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。 间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。 临键锁（Next-Key Lock）：行锁和间隙锁的组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持 4.2、行锁 1）介绍\nInnoDB实现了以下两种类型的行锁：\n共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。 排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。 X IX S IS X 互斥 互斥 互斥 互斥 IX 互斥 兼容 互斥 兼容 S 互斥 互斥 兼容 兼容 IS 互斥 兼容 兼容 兼容 常见的SQL语句，在执行时，所加的行锁如下：\nSQL 行锁类型 说明 INSERT \u0026hellip; 排他锁 自动加锁 UPDATE \u0026hellip; 排他锁 自动加锁 DELETE \u0026hellip; 排他锁 自动加锁 SELECT（正常） 不加任何锁 SELECT \u0026hellip; LOCK IN SHARE MODE 共享锁 需要手动在SELECT之后加LOCK IN SHARE MODE SELECT \u0026hellip; FOR UPDATE 排他锁 需要手动在SELECT之后加FOR UPDATE 2）演示\n共享锁（S） 给id为1的加上共享锁后可以对数据进行查询，但是不能对数据进行更改。\n排他锁（X） 给id=3的加上排他锁后可以对其他事务进行查询但是不能更改和在对它加其他的锁。\n4.3、间隙锁 只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。\n假设，表中有一个范围id为（3，5）间隙锁，那么其他事务就无法插入id=4这条记录了，这样就有效 的防止幻读现象的发生。\n间隙锁虽然存在X型间隙锁和S型间隙锁，但是并没有什么区别，间隙锁之间是兼容的，即两个事务可以 同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出 的。\n4.4、临键锁 Next-Key Lock 称为临键锁，是 Record Lock+ Gap Lock 的组合，锁定一个范围，并且锁定记录本身。\n假设，表中有一个范围 id 为（3，5]的 next-key lock，那么其他事务即不能插入 id= 4 记录，也不能修 改id=5 这条记录。\n所以，next-key lock 即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。 next-keylock是包含间隙锁+记录锁的，如果一个事务获取了×型的next-keylock，那么另外一个事务 在获取相同范围的×型的next-keylock时，是会被阻塞的。\n参考文档\nMySQL数据库官方文档-InnoDB Locking\n","permalink":"http://localhost:1313/posts/mysql%E9%94%81/","summary":"\u003ch1 id=\"mysql锁\"\u003e\u003cstrong\u003eMySQL锁\u003c/strong\u003e\u003c/h1\u003e\n\u003ch2 id=\"1概述\"\u003e\u003cstrong\u003e1、概述\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003e如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。\u003c/p\u003e","title":"MySQL锁"},{"content":"触发器 1.介绍 触发器是与表有关的数据库对象，指在insert/update/delete之前(BEFORE)或之后(AFTER)，触发并执行触发器中定义的SQL语句集合。\n使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。触发器的这种特性可以协助应用在数据库端确保数据的完整性,日志记录,数据校验等操作 。\n触发器类型 NEW和 OLD INSERT型触发器 NEW表示将要或者已经新增的数据 UPDATE型触发器 OLD表示修改之前的数据, NEW表示将要或已经修改后的数据 DELETE型触发器 OLD表示将要或者已经删除的数据 2.语法 1）创建\n1create trigger trigger_name 2before/after insert/update/delete 3on tbl_name for each row --行级触发器 4begin 5 trigger_stmt; 6end; 2)查看\n1show triggers; 3)删除\n1drop trigger [schema_name.]trigger_name; --如果没有指定schema_name,默认为当前数据库。 案例 1-- 通过触发器记录 tb_user 表的数据变更日志，将变更日志插入到日志表user_logs中, 包含增加,修改 , 删除 ; 2 3-- 插入数据触发器 4create trigger tb_user_insert_trigger 5 after insert on tb_user for each row 6begin 7 insert into user_logs(id, operation, operate_time, operate_id, operate_params) 8 values(null,\u0026#39;insert\u0026#39;,now(),new.id, concat(\u0026#39;插入的数据内容为: 9id=\u0026#39;,new.id,\u0026#39;,name=\u0026#39;,new.name, \u0026#39;, phone=\u0026#39;, NEW.phone, \u0026#39;, email=\u0026#39;, NEW.email, \u0026#39;, 10profession=\u0026#39;, NEW.profession)); 11end; 1-- 修改数据触发器 2 3create trigger tb_user_update_trigger 4 after update on tb_user for each row 5begin 6 insert into user_logs(id, operation, operate_time, operate_id, operate_params)values(null,\u0026#39;update\u0026#39;,now(),new.id,concat(\u0026#39;更新之前的数据:id=\u0026#39;,old.id,\u0026#39;,name=\u0026#39;,old.name, \u0026#39;, phone=\u0026#39;, old.phone, \u0026#39;, email=\u0026#39;, old.email, \u0026#39;, profession=\u0026#39;, old.profession, \u0026#39; | 更新之后的数据: id=\u0026#39;,new.id,\u0026#39;,name=\u0026#39;,new.name, \u0026#39;, phone=\u0026#39;, NEW.phone, \u0026#39;, email=\u0026#39;, NEW.email, \u0026#39;, profession=\u0026#39;, NEW.profession)); 7end; 1-- 删除数据触发器 2create trigger tb_user_delete_trigger 3 after delete on tb_user for each row 4begin 5 insert into user_logs(id, operation, operate_time, operate_id, operate_params) 6 value (null,\u0026#39;delete\u0026#39;,now(),old.id, 7 concat(\u0026#39;删除之前的数据: id=\u0026#39;,old.id,\u0026#39;,name=\u0026#39;,old.name, \u0026#39;, phone=\u0026#39;,old.phone, \u0026#39;, email=\u0026#39;, old.email, \u0026#39;, profession=\u0026#39;, old.profession)); 8end; ","permalink":"http://localhost:1313/posts/mysql%E8%A7%A6%E5%8F%91%E5%99%A8/","summary":"\u003ch1 id=\"触发器\"\u003e\u003cstrong\u003e触发器\u003c/strong\u003e\u003c/h1\u003e\n\u003ch2 id=\"1介绍\"\u003e\u003cstrong\u003e1.介绍\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003e触发器是与表有关的数据库对象，指在insert/update/delete之前(BEFORE)或之后(AFTER)，触发并执行触发器中定义的SQL语句集合。\u003c/p\u003e","title":"MySQL触发器"},{"content":"视图-存储过程 一、视图 1.1介绍 视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。\n通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。\n1.2基本语法 创建 1create [or replace] view 视图名称[(列表名称)] as select 语句 [with [cascaded | local] check option] 查询 1查询创建视图语句：show create view 视图名称； 2查看视图数据： select * from 视图名称 ....; 修改 1方式一：create or replace view 视图名称[(列名列表)]] as select 语句[with [cascaded | local] check option] 删除 1drop view [if exists] 视图名称 [,视图名称] ... 1.3检测选项 当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如插入，更新，删除，以使其符合视图的定义。 MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项： CASCADED和 LOCAL，默认值为 CASCADED 。\ncascaded 级联 当使用该属性时在进行视图检查时，上一级的检查条件会向下一级传递，并对每一级进行判断。\nlocal 本地 只会检查当前级别的判定条件。\n1.4视图更新规则 要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新：A.聚合函数或窗口函数（SUM()、 MIN()、 MAX()、 COUNT()等）\nB. DISTINCT\nC. GROUP BY\nD. HAVING\nE. UNION或者 UNION ALL\n1.5视图的好处 简单 视图不仅可以简化数据库使用者对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得使用者不必为以后的操作每次指定全部的条件。\n安全 数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据\n数据独立 视图可帮助用户屏蔽真实表结构变化带来的影响。\n案例 二、存储过程 2.1介绍 存储过程是事先经过编译并存储在数据库中的一段 SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。存储过程思想上很简单，就是数据库 SQL语言层面的代码封装与重用，即SQL的函数。\n特点：\n封装，复用\u0026mdash;》可以把某一业务SQL封装在存储过程中，需要用到的时候直接调用即可。 可以接收参数，也可以返回数据 减少网络交互，提升效率 2.2基本语法 创建 1create procedure 存储过程名称 ([参数列表]) 2begin 3 -- SQL语句 4end; 调用 1call 名称([参数]); 查看 1 2SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = \u0026#39;xxx\u0026#39;; -- 查询指 3定数据库的存储过程及状态信息 4 5show create procedure 存储过程名称; -- 查询某个存储过程的定义 删除 1drop procedure [if exists] 存储过程名称; 2.3变量 在MySQL中变量分为三种类型：系统变量，用户定义变量，局部变量。\n系统变量\n系统变量是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION）。\n查看系统变量 1show [session | global] variables; -- 查看所有系统变量 2SHOW [ SESSION | GLOBAL ] VARIABLES LIKE \u0026#39;......\u0026#39;; -- 可以通过LIKE模糊匹配方式查找变量 3SELECT @@[SESSION | GLOBAL] 系统变量名; -- 查看指定变量的值 设置系统变量 1set [ SESSION | GLOBAL ] 系统变量名 = 值 ; 2SET @@[SESSION | GLOBAL]系统变量名 = 值 ; 如果没有指定session/global,默认是session。\nmysql服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在 /etc/my.cnf 中配置。\n用户定义变量 用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用 \u0026ldquo;@变量\n名\u0026rdquo; 使用就可以。其作用域为当前连接。\n赋值\n方式一：\n1set @var_name=expr [,@var_name=expr]...; 2set @var_name := expr [, @var_name := expr] ... ; 赋值时，可以使用 = ，也可以使用 := 。\n方式二:\n1select @var_name :=expr [,@var_name :=expr]...; 2select 字段名 into @var_name from 表名； 使用\n1select @var_name; 局部变量 局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的\n局部变量和输入参数，局部变量的范围是在其内声明的BEGIN \u0026hellip; END块\n声明\n1declare 变量名 变量类型 [default ...]; 变量类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。\n赋值\n1set 变量名 =值； 2set 变量名 :=值； 3select 字段名 into 变量名 from 表名 ...; 2.4流程控制语句 参数类型\n参数 含义 备注 IN 该类参数作为输入，也就是需要调用时传值 默认 OUT 该类参数作为输出，也就是该参数可以作为返回值 INOUT 既可以作为输入参数，也可以作为输出参数 if\n用于做条件判断，具体的语法结构为：\n1IF 条件1 THEN 2..... 3ELSEIF 条件2 THEN -- 可选 4..... 5ELSE -- 可选 6..... 7END IF; case\n1-- 含义： 当case_value的值为 when_value1时，执行statement_list1，当值为 when_value2时， 2执行statement_list2， 否则就执行 statement_list 3CASE case_value 4 5\tWHEN when_value1 THEN statement_list1 6\t[ WHEN when_value2 THEN statement_list2] ... 7\t[ ELSE statement_list ] 8END CASE; 1-- 含义： 当条件search_condition1成立时，执行statement_list1，当条件search_condition2成 2立时，执行statement_list2， 否则就执行 statement_list 3CASE 4\tWHEN search_condition1 THEN statement_list1 5\t[WHEN search_condition2 THEN statement_list2] ... 6\t[ELSE statement_list] 7END CASE; while\nwhile 循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。具体语法为：\n1-- 先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑 2WHILE 条件 DO 3\tSQL逻辑... 4END WHILE; repeat\nrepeat是有条件的循环控制语句, 当满足until声明的条件的时候，则退出循环 。具体语法为：\n1-- 先执行一次逻辑，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环 2REPEAT 3\tSQL逻辑... 4\tUNTIL 条件 5END REPEAT; loop\nLOOP 实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。\nLOOP可以配合一下两个语句使用：\nleave:配合循环使用，退出循环。类似break。 iterate:必须用在循环中，作用是跳过当前循环剩余的语句，直接进去下一循环。类似countie。 语法：\n[begin_label:] LOOP SQL逻辑... END LOOP [end_label]; LEAVE label; -- 退出指定标记的循环体 ITERATE label; -- 直接进入下一次循环 游标\n游标（CURSOR）是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进\n行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下\n语法 A.声明游标\n1declare 游标名称 cursor for 查询语句; B.打开游标\n1open 游标名称; C.获取游标记录\n1fetch 游标名称 into 变量 [.变量]; D.关闭游标\n1close 游标名称; 案例\n1-- 根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名 2-- （name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表 3-- (id,name,profession)中。 4create procedure p11(in uage int) 5begin 6 declare uname varchar(100); 7 declare pro varchar(100); 8 declare u_cursor cursor for select name ,profession from tb_user where age\u0026lt;=uage; 9 drop table if exists tb_user_pro; 10 create table if not exists tb_user_pro( 11 id int primary key auto_increment, 12 name varchar(100), 13 profession varchar(100) 14 ); 15 open u_cursor ; 16 while true do 17 fetch u_cursor into uname,pro; 18 insert into tb_user_pro values(null,uname,pro); 19 end while; 20 close u_cursor; 21end; 2.5条件处理程序 条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体\n语法为：\n1DECLARE handler_action HANDLER FOR condition_value [, condition_value] 2... statement ; 3handler_action 的取值： 4\tCONTINUE: 继续执行当前程序 5\tEXIT: 终止执行当前程序 6condition_value 的取值： 7\tSQLSTATE sqlstate_value: 状态码，如 02000 8\tSQLWARNING: 所有以01开头的SQLSTATE代码的简写 9\tNOT FOUND: 所有以02开头的SQLSTATE代码的简写 10\tSQLEXCEPTION: 所有没有被SQLWARNING 或 NOT FOUND捕获的SQLSTATE代码的简写 案例\n1create procedure p11(in uage int) 2begin 3 declare uname varchar(100); 4 declare pro varchar(100); 5 declare u_cursor cursor for select name ,profession from tb_user where age\u0026lt;=uage; 6 -- 声明条件处理程序： 当SQL语句执行抛出的状态码为02000时，将关闭游标u_cursor,并退出 7 declare exit handler for SQLSTATE \u0026#39;02000\u0026#39; close u_cursor; 8 drop table if exists tb_user_pro; 9 create table if not exists tb_user_pro( 10 id int primary key auto_increment, 11 name varchar(100), 12 profession varchar(100) 13 ); 14 open u_cursor ; 15 while true do 16 fetch u_cursor into uname,pro; 17 insert into tb_user_pro values(null,uname,pro); 18 end while; 19 close u_cursor; 20end; ","permalink":"http://localhost:1313/posts/%E8%A7%86%E5%9B%BE%E5%92%8C%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/","summary":"\u003ch1 id=\"视图-存储过程\"\u003e\u003cstrong\u003e视图-存储过程\u003c/strong\u003e\u003c/h1\u003e\n\u003ch2 id=\"一视图\"\u003e\u003cstrong\u003e一、视图\u003c/strong\u003e\u003c/h2\u003e\n\u003ch3 id=\"11介绍\"\u003e\u003cstrong\u003e1.1介绍\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。\u003c/p\u003e","title":"MySQL视图和存储过程"},{"content":"SQL优化 插入数据 insert 假设我们需要插入大量数据，那么有哪些方法呢？\n批量插入数据 1INSERT INTO tb_test values(1,\u0026#39;Tom\u0026#39;),(2,\u0026#39;Cat\u0026#39;),(3,\u0026#39;Jerry\u0026#39;); 手动控制事务的提交 1start transaction; 2INSERT INTO tb_test values(1,\u0026#39;Tom\u0026#39;),(2,\u0026#39;Cat\u0026#39;),(3,\u0026#39;Jerry\u0026#39;); 3INSERT INTO tb_test values(4,\u0026#39;Tom\u0026#39;),(5,\u0026#39;Cat\u0026#39;),(6,\u0026#39;Jerry\u0026#39;); 4 5commit; 这两种方法只适用于插入数据在几千条到几万条的，当数据涉及到几十万或者几百万时MySQL也给我们提供了别的方法、\nload 指令 1-- 客户端连接服务端时，加上参数 ---local-infile 2mysql --local-infile -uroot -p 3 4-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关 5set global local_infile =1; 6 7-- 执行load指令将准备好的数据，加载到表结构中 8load data local infile \u0026#39;d:/data/test.log\u0026#39; into table tb_test fields terminated by \u0026#39;,\u0026#39; lines terminated by \u0026#39;\\n\u0026#39;;\u0026#39;; 9 10-- fields terminatedp-每个字段之间使用什么分隔 11-- lines terminated-每条数据之间用什么分隔 主键按顺序插入性能要高于乱序插入：因为插入时需要根据主键进行排序生成索引，当使用乱序时会可能会导致用一页的数据产生分页的现象。\n主键优化 在上一小节，我们提到，主键顺序插入的性能是要高于乱序插入的。这一小节，就来介绍一下具体的原因，然后再分析一下主键又该如何设计。\n1)数据组织方式 在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表(IOT)\n行数据都是存储在聚集索引的叶子节点上的，而InnoDB的逻辑结构是：表-\u0026gt;段 -\u0026gt;区 -\u0026gt;块-\u0026gt; 行\n在InnoDB引擎中。数据行是记录在逻辑结构的page页中的，每一页的大小是16k，一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不小，将会存储到下一个页中，页与页之间会通过指针连接。\n页分裂 页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行溢出)，根据主键排列。\nA. 主键顺序插入效果\n从磁盘中申请页，主键顺序插入 B.主键乱序插入效果\n加入1#，2#页都已经写满了，存放了如图的数据 2.此时在插入id为50的记录，会发生什么现象\n会在开启一个页，写入新的页中？\n不会。因为，索引结构的叶子节点是有顺序的。按照顺序，应该存储在47之后。\n但是在47所在的1#页中已经写满了，存储不了50对应的数据了。那么此时会开辟一个新的页 3#。\n但是不会直接将50存入3#页，而是会将1#页一半的数据移动到3#页没然后3#页，插入50。\n移动数据，并插入id为50的数据之后，那么此时，这三个页之间的数据顺序是有问题的。 1#的下一个页，应该是3#， 3#的下一个页是2#。所以，此时，需要重新设置链表指针。\n上述的这种现象，称之为\u0026quot;页分裂\u0026quot;，是比较耗费性能的操作。\n页合并 当有1#,2#,3#三个页时，假设我们删除了2#页上的50%(MERGE_THRESHOLD)的记录，那么InnoDB会开始开始寻找1#或3#(磁盘最近距离)，看看是否可以将两页合并以优化空间使用。\nMERGE_THRESHOLD:合并页的阈值，可以自己设置，并在创建表或者创建索引时指定。\n索引设计原则 满足业务需求的情况下，尽量降低主键的长度 插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。 业务操作时，避免对主键的修改。 尽量不要使用UUID做主键或者是其他自然主键，如身份证号。 业务操作时，避免对主键的修改。 order by 优化 MySQL的排序，有两种方式：\nUsing filesort:通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort排序。 Using index:通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。 对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，我们在优化排序操作时，尽量要优化为 Using index。\n可以使用explain 查看extra\n为了使排序也使用索引，就需要在创建索引时添加排序。默认也会添加排序方式为asc，也可以自己指定。\n1-- 创建索引 2create index idx_user_age_phone on tb_user(age[asc | desc] ,phone[asc | desc]) 根据age, phone进行降序一个升序，一个降序\n因为创建索引时，如果未指定顺序，默认都是按照升序排序的，而查询时，一个升序，一个降序，此时就会出现Using filesort。\n解决这种问题只需要在创建索引时一个使用desc，一个使用asc。\n我们得出order by优化原则:\nA.根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。\nB.尽量使用覆盖索引。\nC.多字段排序,一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。\nD.如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)。\ngroup by优化 优化思路\nA.在分组操作时，可以通过索引来提高效率。\nB.分组操作时，索引的使用也是满足最左前缀法则的。\n当进行分组查询时如果使用了联合索引那就要符合最左前缀法，如果不使用就会出现Using temporary。\nlimit优化 分页查询，在查询时，越往后，分页查询效率越低。\n优化思路\n一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。\n未使用索引时\n使用索引时\ncount优化 优化方案 在之前的测试中，我们发现，如果数据量很大，在执行count操作时，是非常耗时的。\n而对于count的执行方式不同的引擎也有不同的方法。\nMyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*)的时候会直接返回这个数，效率很高；但是如果是带条件的count，MyISAM也慢。 InnoDB 引擎是它执行count(*) 的时候，需要把数据一行一行的从引擎里面读取出来，然后积累计数。 优化思路：自己计数（可以借助redis这样的数据库进行，但是如果是带条件的count，还是麻烦）。\n不同count使用方法的性能：\ncount(字段)\u0026lt;count(主键)\u0026lt;count(1)|count(*);\nupdate优化 开启事务后，在使用没有的索引的字段机进行update的处理时会产生表锁，\n优化思路\n因为InnoDB的行锁是针对索引加的行锁，不是针对记录加的锁，并且该索引不能失效，否则行锁会升级为表锁。\n","permalink":"http://localhost:1313/posts/sql%E4%BC%98%E5%8C%96/","summary":"\u003ch1 id=\"sql优化\"\u003e\u003cstrong\u003eSQL优化\u003c/strong\u003e\u003c/h1\u003e\n\u003ch2 id=\"插入数据\"\u003e\u003cstrong\u003e插入数据\u003c/strong\u003e\u003c/h2\u003e\n\u003ch3 id=\"insert\"\u003e\u003cstrong\u003einsert\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e假设我们需要插入大量数据，那么有哪些方法呢？\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e批量插入数据\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-mysql\" data-lang=\"mysql\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eINSERT\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eINTO\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003etb_test\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003evalues\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;Tom\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e),(\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;Cat\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e),(\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;Jerry\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pr","title":"SQL优化"},{"content":"复习数据结构二叉树 什么是二叉树？ 二叉树（binary tree）是一种非线性数据结构，代表“祖先”与“后代”之间的派生关系，体现了“一分为二”的分治逻辑。与链表类似，二叉树的基本单元是节点，每个节点包含值、左子节点引用和右子节点引用。每个节点都有两个引用（指针），分别指向左子节点（left-child node）和右子节点（right-child node），该节点被称为这两个子节点的父节点（parent node）。当给定一个二叉树的节点时，我们将该节点的左子节点及其以下节点形成的树称为该节点的左子树（left subtree），同理可得右子树（right subtree）。\n1/* 二叉树节点类 */ 2class TreeNode { 3 int val; // 节点值 4 TreeNode left; // 左子节点引用 5 TreeNode right; // 右子节点引用 6 TreeNode(int x) { val = x; } 7} 二叉树常见术语 根节点（root node）：位于二叉树顶层的节点，没有父节点。 叶节点（leaf node）：没有子节点的节点，其两个指针均指向 None 。 边（edge）：连接两个节点的线段，即节点引用（指针）。 节点所在的层（level）：从顶至底递增，根节点所在层为 1 。 节点的度（degree）：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。 二叉树的高度（height）：从根节点到最远叶节点所经过的边的数量。 节点的深度（depth）：从根节点到该节点所经过的边的数量。 节点的高度（height）：从距离该节点最远的叶节点到该节点所经过的边的数量。 ","permalink":"http://localhost:1313/posts/%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A0%91/","summary":"\u003ch1 id=\"复习数据结构二叉树\"\u003e复习数据结构二叉树\u003c/h1\u003e\n\u003ch2 id=\"什么是二叉树\"\u003e什么是二叉树？\u003c/h2\u003e\n\u003cp\u003e二叉树（binary tree）是一种非线性数据结构，代表“祖先”与“后代”之间的派生关系，体现了“一分为二”的分治逻辑。与链表类似，二叉树的基本单元是节点，每个节点包含值、左子节点引用和右子节点引用。每个节点都有两个引用（指针），分别指向左子节点（left-child node）和右子节点（right-child node），该节点被称为这两个子节点的父节点（parent node）。当给定一个二叉树的节点时，我们将该节点的左子节点及其以下节点形成的树称为该节点的左子树（left subtree），同理可得右子树（right subtree）。\u003c/p\u003e","title":"复习数据结构二叉树"},{"content":"一、Mysql存储引擎 1.Mysql的体系结构 连接层 服务层 引擎层 存储层 2.存储引擎介绍 存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型 。我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎(InnoDB)。\n2.1InnoDB 1).介绍\nInnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5之后，InnoDB是默认的MySQL存储引擎。\n2).特点\n●DML操作遵循ACID模型，支持事务；\n●行锁，提高并发访问性能；\n●支持外键FOREIGN KEY约束，保证数据的完整性和正确性；\n3).文件\n参数：innodb_file_per_table\n1show variables like \u0026#39;innodb_file_per_table\u0026#39;; 如果该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件。，存储该表的表结构（frm-早期的 、sdi-新版的）、数据和索引。\n1show variables like \u0026#39;%datadir%\u0026#39;; 使用上面的命令查看自己表数据存储位置\n4)*逻辑存储结构*\n表空间: InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以包含多个Segment段。 段:表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。 区:区是表空间的单元结构，每个区的大小为1M。默认情况下， InnoDB存储引擎页大小为16K，即一个区中一共有64个连续的页。 页:页是组成区的最小单元，页也是InnoDB存储引擎磁盘管理的最小单元 ，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB存储引擎每次从磁盘申请 4-5个区。 行: InnoDB存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段(后面会详细介绍)。 2.2 MyISAM 1).介绍\nMyISAM是MySQL早期的默认存储引擎。\n2).特点\n不支持事务，不支持外键\n支持表锁，不支持行锁\n访问速度快\n2.3Memory 1).介绍\nMemory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。\n2).特点\n存放在内存中\nhash索引（默认）\n2.4三种索引的区别 二、索引 索引概述 索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。\n无索引和有索引的情况下 假如我们要执行的SQL语句为 ： select* from user where age= 45;\n在无索引的情况下会对全表进行扫描效率很低\n在有索引时我们可以根据这个表建立索引，一般索引都是B+tree，然后会根据age进行查找\n优势 劣势 提高数据检索的效率，降低数据库IO成本 索引列也要占用空间 通过索引列对数据进行排序，降低降低CPU的消耗 数据排序的成本，降低CPU的消耗。 索引大大提高了查询效率，同时却也降低更新表的速度如对表进行INSERT、UPDATE、DELETE时，效率降低 索引结构 索引结构 描述 B+Tree索引 最常见的索引类型，大部分引擎都支持 B+树索引 Hash索引 底层数据结构是用哈希表实现的,只有精确匹配索引列的查询才有效,不支持范围查询 R-tree(空间索引） 空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 Full-text(全文索引) 是一种通过建立倒排索引，快速匹配文档的方式。类似于Lucene, Solr,ES 上述是MySQL中所支持的所有的索引结构，接下来，我们再来看看不同的存储引擎对于索引结构的支持情况。\n索引分类 在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。\n索引基础分类 分类 含义 特点 关键字 主键索引 针对于表中主键创建的索引 默认自动创建,只能有一个 PRIMARY 唯一索引 避免同一个表中某数据列中的值重复 可以有多个 UNIQUE 常规索引 快速定位特定数据 可以有多个 全文索引 全文索引查找的是文本中的关键词，而不是比较索引中的值 可以有多个 FULLTEXT 聚集索引\u0026amp;二级索引 而在在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：\n分类 含义 特点 聚集索引(ClusteredIndex) 将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据 必须有,而且只有一个 二级索引(SecondaryIndex) 将数据与索引分开存储，索引结构的叶子节点关 可以存在多个 聚集索引选取规则:\n如果存在主键，主键索引就是聚集索引。 如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。 接下来，我们来分析一下，当我们执行如下的SQL语句时，具体的查找过程是什么样子的。\n具体过程如下:\n①.由于是根据name字段进行查询，所以先根据name=\u0026lsquo;Arm\u0026rsquo;到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm对应的主键值 10。\n②.由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到10对应的行row。\n③.最终拿到这一行的数据，直接返回即可。\n回表查询： 这种先到二级索引中查找数据，找到主键值, 然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询\n索引语法 1）创建索引\n1CREATE [UNIQUE | FULLTEXT] INDEX index_name NO table_name(index_col_name,....); 2）查看索引\n1SHOW INDEX FROM table_name; 3)删除索引\n1DROP INDEX index_name NO table_name; 三、SQL性能分析 3.1SQL执行频率 MySQL客户端连接成功后，通过 show[ session | global ] status命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：\n1-- session 是查看当前会话； 2-- global 是查询全局数据； 3 SHOW GLOBAL STATUS LIKE \u0026#39;COM_______\u0026#39;; 通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。如果是以增删改为主，我们可以考虑不对其进行索引的优化。如果是以查询为主，那么就要考虑对数据库的索引进行优化了。\n3.2慢查询日志 慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。\nMySQL的慢查询日志默认没有开启，我们可以查看一下系统变量 slow_query_log。\n1show variables like \u0026#39;%quer%\u0026#39;; 在windos下开启慢查询 临时开启慢查询（重启MySQL后就会失效）\n1set global slow_query_log=\u0026#39;ON\u0026#39;; 2 3--设置慢查询日志存放的位置 4set global slow_query_log_file=\u0026#39;D:\\\\home\\\\mysql.log\u0026#39;; 永久开启慢查询（mysql版本5.7.30）\n找到mysql的安装目录，找到my.ini文件夹在[mysqld]处加入以下代码开启慢查询，永久有效。\n#存储位置 datadir=D:/soft/mysql-5.30/Data #开启慢查询 slow-query-log=1 #D:/soft/mysql-5.30/Data/HJH-slow.log 慢查询日志文件存储位置 slow_query_log_file=\u0026#34;HJH-slow.log\u0026#34; #慢查询判断时间 long_query_time=10 在Ubuntu中开启慢查询 //TODO\nprofile详情 show profiles能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前MySQL是否支持profile操作： 1-- 查看数据库是否支持profile 2SELECT @@have_profiling; 3 4-- 开启profile 5SET [session | global]profiling = 1; 开启profiling后就能使用profiling相关命令来查询执行过的SQL语句\n执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时：\n1 -- 查看每一条SQL的耗时基本情况 2show profiles; 3 4-- 查看指定query_id的SQL语句各个阶段的耗时情况 5show profile for query query_id; 6 7-- 查看指定query_id的SQL语句CPU的使用情况 8show profile cpu for query query_id; explain EXPLAIN或者 DESC命令获取 MySQL如何执行 SELECT语句的信息，包括在 SELECT语句执行过程中表如何连接和连接的顺序。\n1-- 直接在select语句前加上关键字 explain/desc 2EXPLAIN SELECT 字段列表 FROM 表明 WHERE 条件; Explain执行计划中各个字段的含义:\n字段 含义 id select查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下；id不同，值越大，越先执行)。 select_type 表示 SELECT的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等 type 表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、 index、all 。 possible_key 显示可能应用在这张表上的索引，一个或多个。 key 实际使用的索引，如果为NULL，则没有使用索引。 key_len 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好 。 rows MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。 filtered 表示返回结果的行数占需读取行数的百分比， filtered的值越大越好。 Extra Using where: Using Index 查找使用了索引，但是需要的数据都在索引列表中找到，所以不需要回表查询 。Using index condition:查找使用了索引，但是需要回表查询数据 五、索引的使用 最左前缀法则 使用联合索引时要遵守最左前缀法则。最左前缀法则是指在查询索引时从索引的最左列开始，并且不跳过索引中的列。如果跳过某一列，后面的字段索引失效。\ntb_user表\n1create table tb_user( 2\tid int primary key auto_increment comment \u0026#39;主键\u0026#39;, 3\tname varchar(50) not null comment \u0026#39;用户名\u0026#39;, 4\tphone varchar(11) not null comment \u0026#39;手机号\u0026#39;, 5\temail varchar(100) comment \u0026#39;邮箱\u0026#39;, 6\tprofession varchar(11) comment \u0026#39;专业\u0026#39;, 7\tage tinyint unsigned comment \u0026#39;年龄\u0026#39;, 8\tgender char(1) comment \u0026#39;性别 , 1: 男, 2: 女\u0026#39;, 9\tstatus char(1) comment \u0026#39;状态\u0026#39;, 10\tcreatetime datetime comment \u0026#39;创建时间\u0026#39; 11) comment \u0026#39;系统用户表\u0026#39;; 12 13 14INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;吕布\u0026#39;, \u0026#39;17799990000\u0026#39;, \u0026#39;lvbu666@163.com\u0026#39;, \u0026#39;软件工程\u0026#39;, 23, \u0026#39;1\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;2001-02-02 00:00:00\u0026#39;); 15INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;曹操\u0026#39;, \u0026#39;17799990001\u0026#39;, \u0026#39;caocao666@qq.com\u0026#39;, \u0026#39;通讯工程\u0026#39;, 33, \u0026#39;1\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;2001-03-05 00:00:00\u0026#39;); 16INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;赵云\u0026#39;, \u0026#39;17799990002\u0026#39;, \u0026#39;17799990@139.com\u0026#39;, \u0026#39;英语\u0026#39;, 34, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;2002-03-02 00:00:00\u0026#39;); 17INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;孙悟空\u0026#39;, \u0026#39;17799990003\u0026#39;, \u0026#39;17799990@sina.com\u0026#39;, \u0026#39;工程造价\u0026#39;, 54, \u0026#39;1\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;2001-07-02 00:00:00\u0026#39;); 18INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;花木兰\u0026#39;, \u0026#39;17799990004\u0026#39;, \u0026#39;19980729@sina.com\u0026#39;, \u0026#39;软件工程\u0026#39;, 23, \u0026#39;2\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2001-04-22 00:00:00\u0026#39;); 19INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;大乔\u0026#39;, \u0026#39;17799990005\u0026#39;, \u0026#39;daqiao666@sina.com\u0026#39;, \u0026#39;舞蹈\u0026#39;, 22, \u0026#39;2\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;2001-02-07 00:00:00\u0026#39;); 20INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;露娜\u0026#39;, \u0026#39;17799990006\u0026#39;, \u0026#39;luna_love@sina.com\u0026#39;, \u0026#39;应用数学\u0026#39;, 24, \u0026#39;2\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;2001-02-08 00:00:00\u0026#39;); 21INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;程咬金\u0026#39;, \u0026#39;17799990007\u0026#39;, \u0026#39;chengyaojin@163.com\u0026#39;, \u0026#39;化工\u0026#39;, 38, \u0026#39;1\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;2001-05-23 00:00:00\u0026#39;); 22INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;项羽\u0026#39;, \u0026#39;17799990008\u0026#39;, \u0026#39;xiaoyu666@qq.com\u0026#39;, \u0026#39;金属材料\u0026#39;, 43, \u0026#39;1\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;2001-09-18 00:00:00\u0026#39;); 23INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;白起\u0026#39;, \u0026#39;17799990009\u0026#39;, \u0026#39;baiqi666@sina.com\u0026#39;, \u0026#39;机械工程及其自动化\u0026#39;, 27, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;2001-08-16 00:00:00\u0026#39;); 24INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;韩信\u0026#39;, \u0026#39;17799990010\u0026#39;, \u0026#39;hanxin520@163.com\u0026#39;, \u0026#39;无机非金属材料工程\u0026#39;, 27, \u0026#39;1\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;2001-06-12 00:00:00\u0026#39;); 25INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;荆轲\u0026#39;, \u0026#39;17799990011\u0026#39;, \u0026#39;jingke123@163.com\u0026#39;, \u0026#39;会计\u0026#39;, 29, \u0026#39;1\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;2001-05-11 00:00:00\u0026#39;); 26INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;兰陵王\u0026#39;, \u0026#39;17799990012\u0026#39;, \u0026#39;lanlinwang666@126.com\u0026#39;, \u0026#39;工程造价\u0026#39;, 44, \u0026#39;1\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2001-04-09 00:00:00\u0026#39;); 27INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;狂铁\u0026#39;, \u0026#39;17799990013\u0026#39;, \u0026#39;kuangtie@sina.com\u0026#39;, \u0026#39;应用数学\u0026#39;, 43, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;2001-04-10 00:00:00\u0026#39;); 28INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;貂蝉\u0026#39;, \u0026#39;17799990014\u0026#39;, \u0026#39;84958948374@qq.com\u0026#39;, \u0026#39;软件工程\u0026#39;, 40, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;2001-02-12 00:00:00\u0026#39;); 29INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;妲己\u0026#39;, \u0026#39;17799990015\u0026#39;, \u0026#39;2783238293@qq.com\u0026#39;, \u0026#39;软件工程\u0026#39;, 31, \u0026#39;2\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;2001-01-30 00:00:00\u0026#39;); 30INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;芈月\u0026#39;, \u0026#39;17799990016\u0026#39;, \u0026#39;xiaomin2001@sina.com\u0026#39;, \u0026#39;工业经济\u0026#39;, 35, \u0026#39;2\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;2000-05-03 00:00:00\u0026#39;); 31INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;嬴政\u0026#39;, \u0026#39;17799990017\u0026#39;, \u0026#39;8839434342@qq.com\u0026#39;, \u0026#39;化工\u0026#39;, 38, \u0026#39;1\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2001-08-08 00:00:00\u0026#39;); 32INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;狄仁杰\u0026#39;, \u0026#39;17799990018\u0026#39;, \u0026#39;jujiamlm8166@163.com\u0026#39;, \u0026#39;国际贸易\u0026#39;, 30, \u0026#39;1\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;2007-03-12 00:00:00\u0026#39;); 33INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;安琪拉\u0026#39;, \u0026#39;17799990019\u0026#39;, \u0026#39;jdodm1h@126.com\u0026#39;, \u0026#39;城市规划\u0026#39;, 51, \u0026#39;2\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;2001-08-15 00:00:00\u0026#39;); 34INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;典韦\u0026#39;, \u0026#39;17799990020\u0026#39;, \u0026#39;ycaunanjian@163.com\u0026#39;, \u0026#39;城市规划\u0026#39;, 52, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;2000-04-12 00:00:00\u0026#39;); 35INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;廉颇\u0026#39;, \u0026#39;17799990021\u0026#39;, \u0026#39;lianpo321@126.com\u0026#39;, \u0026#39;土木工程\u0026#39;, 19, \u0026#39;1\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;2002-07-18 00:00:00\u0026#39;); 36INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;后羿\u0026#39;, \u0026#39;17799990022\u0026#39;, \u0026#39;altycj2000@139.com\u0026#39;, \u0026#39;城市园林\u0026#39;, 20, \u0026#39;1\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;2002-03-10 00:00:00\u0026#39;); 37INSERT INTO itcast.tb_user (name, phone, email, profession, age, gender, status, createtime) VALUES (\u0026#39;姜子牙\u0026#39;, \u0026#39;17799990023\u0026#39;, \u0026#39;37483844@qq.com\u0026#39;, \u0026#39;工程造价\u0026#39;, 29, \u0026#39;1\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;2003-05-26 00:00:00\u0026#39;); 在 tb_user表中，有一个联合索引，这个联合索引涉及到三个字段，顺序分别为：profession， age，status。\n对于最左前缀法则指的是，查询时，最左边的列，也就是profession必须存在，否则索引全部失效。\n从图中可以看出只要有profession存在就会使用索引，当profession不存在即使使用后面的属性也不会触发索引。\n思考题： 当执行SQL语句: explain select * from tb_user where age = 3 and status=\u0026lsquo;0’ and profession=\u0026lsquo;软件工程\u0026rsquo;;时，是否满足最左前缀法则，走不走 上述的联合索引，索引长度？\n很显然时走的，最左前缀法则中指的最最左边的列，是指在查询时，联合索引的最左边的字段（就是第一个字段）必须存在，与我们编写SQL时。条件的顺序无关。\n范围查询 联合索引中，出现范围查询(\u0026gt;,\u0026lt;)，范围查询右侧的列索引失效。\n在使用范围查询时有效字段是38，但是在不使用时有效字段是42，说明在使用范围查询时有字段失效了。\n所以在业务允许的情况下，尽可能的使用类似的\u0026gt;=或\u0026lt;=这类的范围查询。\n范围失效的情况 索引列运算 不要在索引列上进行运算操作，索引将失效。\n字符串不加引号 不要在索引列上进行运算操作，索引将失效。\n模糊查询使用头部模糊查询，索引失效 如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。\nor连接条件 用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。\n-数据分布影响。\n如果MySQL评估使用索引比全表更慢，则不使用索引。\nSQL提示 SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的\n1). use index ：建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进行评估）。\n1explain select * from tb_user use index(idx_user_pro) where profession=\u0026#39;软件工程\u0026#39; 2). ignore index ：忽略指定的索引。\n1explain select * from tb_user ignore index(idx_user_pro) where profession=\u0026#39;软件工程\u0026#39; 3). force index ：强制使用索引。\n1explain select * from tb_user ignore index(idx_user_pro) where profession=\u0026#39;软件工程\u0026#39; 覆盖索引 尽量使用覆盖索引，减少select*。那么什么是覆盖索引呢？覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。\nB.执行SQL: select * from tb_user where id =2;\n根据id查询，直接走聚集索引查询一次索引扫描，直接返回数据，性能高。\nc.执行SQL: select id ,name from tb_user where name =\u0026lsquo;Arm\u0026rsquo;;\n根据name字段查询辅助索引，id和name在name的二级索引中都是可以直接获取到的，所以不需要回表查询，性能高。\nd.执行SQL:select id ,name ,gender from tb_user where name =\u0026lsquo;Arm\u0026rsquo;;\n由于在name的二级索引中，不包含gender，所以，需要两次索引扫描，也就是需要回表查询，性能相对较差一点。\n前缀索引 当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。\n1).语法\n1create index idx_xxxx on table_name(colum(n)); 示例\n在tb_user的表的email字段，建立长度未5的前缀索引。\n1create index idx_email_5 on tb_user(email(5)); 2)查询流程\n单列索引和联合索引 单列索引：即一个索引只包含单个列。\n联合索引：即一个索引包含了多个列。\n在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。\n索引设计原则 1).针对于数据量较大，且查询比较频繁的表建立索引。\n2).针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。\n3).尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。\n4).如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。\n5).尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。\n6).要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。\n7).如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。\n","permalink":"http://localhost:1313/posts/mysql%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D/","summary":"\u003ch1 id=\"一mysql存储引擎\"\u003e\u003cstrong\u003e一、Mysql存储引擎\u003c/strong\u003e\u003c/h1\u003e\n\u003ch2 id=\"1mysql的体系结构\"\u003e\u003cstrong\u003e1.Mysql的体系结构\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.postimg.cc/MpV3xV4W/screenshot-16.png\" alt=\"\"  /\u003e\r\n\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e连接层\u003c/li\u003e\n\u003cli\u003e服务层\u003c/li\u003e\n\u003cli\u003e引擎层\u003c/li\u003e\n\u003cli\u003e存储层\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"2存储引擎介绍\"\u003e\u003cstrong\u003e2.存储引擎介绍\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003e存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是基于库的，\u003ccode\u003e所以存储引擎也可被称为表类型\u003c/code\u003e 。我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎(InnoDB)。\u003c/p\u003e","title":"Mysql存储引擎"},{"content":"事务 事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。\n使用到的关键字 1set autocommit=0; 2start transaction; 3commit; 4rollback; 5 6savepoint 断点 7commit to 断点 8rollback to 断点 事务四大特性 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据改变就是永久的 并发事务问题 1） 脏读：一个事务读到另一个事务还没有提交的数据\n比如B读取到了A未提交的数据。\n2） 不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称为不可重复读。\n事务A两次读取同一条记录，但是读取到的数据却是不一样的。\n3） 幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据\n不可重复读和幻读的区别\n不可重复读是读取了其他事务更改的数据 -\u0026gt;update 幻读是读取了其他事务新增的数据 -\u0026gt;insert和delete\n事务的隔离级别 为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。\n数据库事务的隔离级别有4个，由低到高依次为Read uncommitted 、Read committed 、Repeatable read 、Serializable ，这四个级别可以逐个解决脏读 、不可重复读 、幻读 这几类问题。\nMySql默认REPEATABLE_READ\n隔离级别 脏读 不可重复读 幻读 Read uncommitted(读未提交) Y Y Y Read committed(读以提交) N Y Y Repeatable Read(可重复读) N N Y Serializable N N N 查看事务隔离级别 1SELECT @@TRANSACTION_ISOLATION; 设置事务隔离级别 1SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL { READ UNCOMMITTED | 2READ COMMITTED | REPEATABLE READ | SERIALIZABLE } ","permalink":"http://localhost:1313/posts/mysql%E4%BA%8B%E5%8A%A1/","summary":"\u003ch1 id=\"事务\"\u003e事务\u003c/h1\u003e\n\u003cp\u003e事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。\u003c/p\u003e","title":"Mysql事务"},{"content":"Mysql常用函数 聚合函数 函数 功能 count 统计数量 max 最大值 min 最小值 avg 平均值 sum 求和 字符串函数 函数 功能 CONCAT(S1,S2,\u0026hellip;Sn) 字符串拼接，将S1，S2，\u0026hellip; Sn拼接成一个字符串 LOWER(str) 将字符串str全部转为小写 UPPER(str) 将字符串str全部转为大写 LPAD(str,n,pad) 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 RPAD(str,n,pad) 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 TRIM(str) 去掉字符串头部和尾部的空格 SUBSTRING(str,start,len) 返回从字符串str从start位置起的len个长度的字符串 数值函数 函数 功能 CEIL(x) 向上取整 FLOOR(x) 向下取整 MOD(x,y) 返回x/y的模 RAND() 返回0~1内的随机数 ROUND(x,y) 求参数x的四舍五入的值，保留y位小数 例题：\n通过数据库的函数，生成一个六位数的随机验证码。\n1 select lpad(round(rand()*1000000,0),6,\u0026#39;0\u0026#39;) 日期函数 函数 功能 CURDATE() 返回当前日期 CURTIME() 返回当前时间 NOW() 返回当前日期和时间 YEAR(date) 获取指定date的年份 MONTH(date) 获取指定date的月份 DAY(date) 获取指定date的日期 DATE_ADD(date, INTERVAL exprtype) 返回一个日期/时间值加上一个时间间隔expr后的时间值 DATEDIFF(date1,date2) 返回起始时间date1 和 结束时间date2之间的天数 例题：\n查询所有员工的入职天数，并根据入职天数倒序排序\n1 select name, datediff(curdate(), entrydate) as \u0026#39;entrydays\u0026#39; from emp order by 2 entrydays desc; 流程函数 函数 功能 IF(value , t , f) 如果value为true，则返回t，否则返回f IFNULL(value1 , value2) 如果value1不为空，返回value1，否则返回value2 CASE WHEN [ val1 ] THEN [res1] \u0026hellip;ELSE [ default ] END 如果val1为true，返回res1，\u0026hellip; 否则返回default默认值 CASE [ expr ] WHEN [ val1 ] THEN[res1] \u0026hellip; ELSE [ default ] END 如果expr的值等于val1，返回res1，\u0026hellip; 否则返回default默认值 ","permalink":"http://localhost:1313/posts/mysql%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/","summary":"\u003ch1 id=\"mysql常用函数\"\u003eMysql常用函数\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"https://i.postimg.cc/cJQ332yQ/screenshot-12.png\" /\u003e\u003cbr\u003e\u003c/p\u003e\n\u003ch2 id=\"聚合函数\"\u003e\u003cstrong\u003e聚合函数\u003c/strong\u003e\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: left\"\u003e函数\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e功能\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003ecount\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e统计数量\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003emax\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e最大值\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003emin\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e最小值\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eavg\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e平均值\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003esum\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e求和\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"字符串函数\"\u003e\u003cstrong\u003e字符串函数\u003c/strong\u003e\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: left\"\u003e函数\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e功能\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eCONCAT(S1,S2,\u0026hellip;Sn)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e字符串拼接，将S1，S2，\u0026hellip; Sn拼接成一个字符串\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eLOWER(str)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e将字符串str全部转为小写\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eUPPER(str)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e将字符串str全部转为大写\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eLPAD(str,n,pad)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e左填充，用字符串pad对str的左边进行填充，达到n个字符串长度\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eRPAD(str,n,pad)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e右填充，用字符串pad对str的右边进行填充，达到n个字符串长度\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eTRIM(str)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e去掉字符串头部和尾部的空格\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eSUBSTRING(str,start,len)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e返回从字符串str从start位置起的len个长度的字符串\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"数值函数\"\u003e\u003cstrong\u003e数值函数\u003c/strong\u003e\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: left\"\u003e函数\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e功能\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eCEIL(x)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e向上取整\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eFLOOR(x)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e向下取整\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eMOD(x,y)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e返回x/y的模\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eRAND()\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e返回0~1内的随机数\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eROUND(x,y)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e求参数x的四舍五入的值，保留y位小数\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e例题：\u003cbr\u003e\n通过数据库的函数，生成一个六位数的随机验证码。\u003c/p\u003e","title":"Mysql常用函数"},{"content":"配置硬件加速 使用SDK 管理器安装 1.选择Tools\u0026gt;SDK Manger\n2.点击 SDK Tools 标签页，然后选择 Android Emulator Hypervisor Driver\n3.点击 OK，以下载并安装 Android Emulator Hypervisor Driver。\n4.安装后，返回命令行中使用以下命令，确认驱动程序能正常运行：\n1sc query aehd 如何出现错误先尝试关闭 Hyper-V 禁用Hyper-V 在控制面板中禁用 Hyper-V 1.在dos窗口或者powershell中运行命令\n1control 2.点击程序\n3.点击启用或者关闭Windos功能\n4.展开 Hyper-V，展开 Hyper-V 平台，然后清除“Hyper-V 虚拟机监控程序”复选框。 在PowerShell 中禁用 Hyper-V 1.提升PowerShell 窗口的权限为管理员\n1 sudo 2.运行以下命令\n1Disable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V-Hypervisor 参考文献\n虚拟化应用程序无法与 Hyper-V、Device Guard 和 Credential Guard 协同工作\n","permalink":"http://localhost:1313/posts/stop-hyper-v/","summary":"\u003ch1 id=\"配置硬件加速\"\u003e配置硬件加速\u003c/h1\u003e\n\u003ch2 id=\"使用sdk-管理器安装\"\u003e使用SDK 管理器安装\u003c/h2\u003e\n\u003cp\u003e1.选择Tools\u0026gt;SDK Manger\u003cbr\u003e\n\u003cimg src=\"https://i.postimg.cc/g2zgzhDN/screenshot-9.png\" /\u003e\u003c/p\u003e","title":"Stop Hyper V"},{"content":"java集合简介 一、集合基本的关系结构 Collection 接口的接口 对象的集合（单列集合）\nList 接口：元素按进入先后有序保存，可重复 LinkedList 接口实现类， 链表， 插入删除， 没有同步， 线程不安全 ArrayList 接口实现类， 数组， 随机访问， 没有同步， 线程不安全 Vector 接口实现类 数组， 同步， 线程安全 Stack 是Vector类的实现类 Set 接口： 仅接收一次，不可重复，并做内部排序 HashSet 使用hash表（数组）存储元素 LinkedHashSet 链表维护元素的插入次序 TreeSet 底层实现为二叉树，元素排好序 Map 接口 键值对的集合 （双列集合）\nHashtable 接口实现类， 同步， 线程安全 HashMap 接口实现类 ，没有同步， 线程不安全 LinkedHashMap 双向链表和哈希表实现 WeakHashMap TreeMap 红黑树对所有的key进行排序 IdentifyHashMap 二、Collection接口及方法 2.1 添加 （1）add(E obj)：添加元素对象到当前集合中\n（2）addAll(Collection other)：添加other集合中的所有元素对象到当前集合中，即this = this ∪ other\n2.2 判断 （3）int size()：获取当前集合中实际存储的元素个数\n（4）boolean isEmpty()：判断当前集合是否为空集合\n（5）boolean contains(Object obj)：判断当前集合中是否存在一个与obj对象equals返回true的元素\n（6）boolean containsAll(Collection coll)：判断coll集合中的元素是否在当前集合中都存在。即coll集合是否是当前集合的“子集”\n（7）boolean equals(Object obj)：判断当前集合与obj是否相等\n2.3 删除 （8）void clear()：清空集合元素\n（9） boolean remove(Object obj) ：从当前集合中删除第一个找到的与obj对象equals返回true的元素。\n（10）boolean removeAll(Collection coll)：从当前集合中删除所有与coll集合中相同的元素。即this = this - this ∩ coll （11）boolean retainAll(Collection coll)：从当前集合中删除两个集合中不同的元素，使得当前集合仅保留与coll集合中的元素相同的元素，即当前集合中仅保留两个集合的交集，即this = this ∩ coll；\n2.4其他 （12）Object[] toArray()：返回包含当前集合中所有元素的数组\n（13）hashCode()：获取集合对象的哈希值\n（14）iterator()：返回迭代器对象，用于集合遍历\n三、List集合 3.1 List接口特点 List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。\nJDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。\n3.2 List接口方法 List除了从Collection集合继承的方法外，List 集合里添加了一些根据索引来操作集合元素的方法。\n插入元素 void add(int index,Object ele); 在哦index位置插入ele元素 boolean add(int index ,Collection eles);从index位置开始将eles中的所有元素添加进来 获取元素 Object get(int inedx);获取指定index位置的元素 List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合 获取元素索引 int indexOf(Object obj):返回obj在集合中首次出现的位置 int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置 删除和替换元素 Object remove(int index):移除指定index位置的元素，并返回此元素 Object set(int index, Object ele):设置指定index位置的元素为ele 3.3 List接口主要实现类：ArrayList ArrayList 是 List 接口的主要实现类 本质上，ArrayList是对象引用的一个”变长”数组 Arrays.asList(…) 方法返回的 List 集合，既不是 ArrayList 实例，也不是 Vector 实例。 Arrays.asList(…) 返回值是一个固定长度的 List 集合 3.4 List的实现类之二：LinkedList 对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高。这是由底层采用链表（双向链表）结构存储数据决定的。 特有方法 void addFirst(Object obj) void addLast(Object obj) Object getFirst() Object getLast() Object removeFirst() Object removeLast() 3.5 List的实现类之三：Vector Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的。 在各种List中，最好把ArrayList作为默认选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用。 四、Set集合 4.1 Set接口概述 Set接口是Collection的子接口，Set接口相较于Collection接口没有提供额外的方法 Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个 Set 集合中，则添加操作失败。 Set集合支持的遍历方式和Collection集合一样：foreach和Iterator。 Set的常用实现类有：HashSet、TreeSet、LinkedHashSet。 4.2 Set主要实现类：HashSet HashSet 是 Set 接口的主要实现类，大多数时候使用 Set 集合时都使用这个实现类。\nHashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存储、查找、删除性能。\nHashSet 具有以下特点：\n不能保证元素的排列顺序 HashSet 不是线程安全的 集合元素可以是 null HashSet 集合判断两个元素相等的标准：两个对象通过 hashCode() 方法得到的哈希值相等，并且两个对象的 equals() 方法返回值为true。\n对于存放在Set容器中的对象，对应的类一定要重写hashCode()和equals(Object obj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”。\nHashSet集合中元素的无序性，不等同于随机性。这里的无序性与元素的添加位置有关。具体来说：我们在添加每一个元素到数组中时，具体的存储位置是由元素的hashCode()调用后返回的hash值决定的。导致在数组中每个元素不是依次紧密存放的，表现出一定的无序性。\n4.3 Set实现类之二：LinkedHashSet LinkedHashSet 是 HashSet 的子类，不允许集合元素重复。\nLinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以添加顺序保存的。\nLinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。\n4.4 Set实现类之三：TreeSet TreeSet 是 SortedSet 接口的实现类，TreeSet 可以按照添加的元素的指定的属性的大小顺序进行遍历。 TreeSet底层使用红黑树结构存储数据 五 Map接口 现实生活与开发中，我们常会看到这样的一类集合：用户ID与账户信息、学生姓名与考试成绩、IP地址与主机名等，这种一一对应的关系，就称作映射。Java提供了专门的集合框架用来存储这种映射关系的对象，即java.util.Map接口。\n5.1 Map接口概述 Map与Collection并列存在。用于保存具有映射关系的数据：key-value\nCollection集合称为单列集合，元素是孤立存在的。 Map集合称为双列集合，元素是成对存在的。 Map 中的 key 和 value 都可以是任何引用类型的数据。但常用String类作为Map的“键”。\nMap接口的常用实现类：HashMap、LinkedHashMap、TreeMap和``Properties。其中，HashMap是 Map 接口使用频率最高`的实现类。\n5.2 Map接口的常用方法 添加、修改操作： Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中 void putAll(Map m):将m中的所有key-value对存放到当前map中 删除操作： Object remove(Object key)：移除指定key的key-value对，并返回value void clear()：清空当前map中的所有数据 元素查询的操作： Object get(Object key)：获取指定key对应的value boolean containsKey(Object key)：是否包含指定的key boolean containsValue(Object value)：是否包含指定的value int size()：返回map中key-value对的个数 boolean isEmpty()：判断当前map是否为空 boolean equals(Object obj)：判断当前map和参数对象obj是否相等 元视图操作的方法： Set keySet()：返回所有key构成的Set集合 Collection values()：返回所有value构成的Collection集合 Set entrySet()：返回所有key-value对构成的Set集合 5.3 Map的主要实现类：HashMap 5.3.1 HashMap概述 HashMap是 Map 接口使用频率最高的实现类。 HashMap是线程不安全的。允许添加 null 键和 null 值。 存储数据采用的哈希表结构，底层使用一维数组+单向链表+红黑树进行key-value数据的存储。与HashSet一样，元素的存取顺序不能保证一致。 HashMap 判断两个key相等的标准是：两个 key 的hashCode值相等，通过 equals() 方法返回 true。 HashMap 判断两个value相等的标准是：两个 value 通过 equals() 方法返回 true。 5.4 Map实现类之二：LinkedHashMap LinkedHashMap 是 HashMap 的子类 存储数据采用的哈希表结构+链表结构，在HashMap存储结构的基础上，使用了一对双向链表来记录添加元素的先后顺序，可以保证遍历元素时，与添加的顺序一致。 通过哈希表结构可以保证键的唯一、不重复，需要键所在类重写hashCode()方法、equals()方法。 5.5 Map实现类之三：TreeMap TreeMap存储 key-value 对时，需要根据 key-value 对进行排序。TreeMap 可以保证所有的 key-value 对处于有序状态。 TreeSet底层使用红黑树结构存储数据 TreeMap 的 Key 的排序： 自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException 定制排序：创建 TreeMap 时，构造器传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现 Comparable 接口 TreeMap判断两个key相等的标准：两个key通过compareTo()方法或者compare()方法返回0。 5.6 Map实现类之四：Hashtable Hashtable是Map接口的古老实现类，JDK1.0就提供了。不同于HashMap，Hashtable是线程安全的。 Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构（数组+单向链表），查询速度快。 与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序 Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。 与HashMap不同，Hashtable 不允许使用 null 作为 key 或 value。 5.7 Map实现类之五：Properties Properties 类是 Hashtable 的子类，该对象用于处理属性文件\n由于属性文件里的 key、value 都是字符串类型，所以 Properties 中要求 key 和 value 都是字符串类型\n存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法\n","permalink":"http://localhost:1313/posts/java%E9%9B%86%E5%90%88%E5%A4%8D%E4%B9%A0/","summary":"\u003ch1 id=\"java集合简介\"\u003ejava集合简介\u003c/h1\u003e\n\u003ch2 id=\"一集合基本的关系结构\"\u003e一、集合基本的关系结构\u003c/h2\u003e\n\u003cp\u003eCollection 接口的接口 对象的集合（单列集合）\u003c/p\u003e","title":"Java集合复习"},{"content":"MySQL的基本操作 1、查看所有的数据库\n1show datebases; 2、创建自己的数据库\n1create datebase 数据库名字; 3、使用自己的数据库\n1use 数据库名字; 说明：如果没有使用use语句，后面针对数据库的操作也没有加“数据名”的限定，那么会报“ERROR 1046 (3D000): No database selected”（没有选择数据库） 使用完use语句之后，如果接下来的SQL都是针对一个数据库操作的，那就不用重复use了，如果要针对另 一个数据库操作，那么要重新use。\n4、查看某个库的所有表格\n1show tables; #要求前面有use语句 2show tables from 数据库名; 5、创建新的表格\n1create table 表名称( 2字段名 数据类型, 3字段名 数据类型 4); 6、查看一个表的数据\n1select * from 数据库表名称; 7、添加一条记录\n1nsert into 表名称 values(值列表); 8、删除表格\n1drop table 表名称; 11、删除数据库\n1drop database 数据库名; ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003ch1 id=\"mysql的基本操作\"\u003eMySQL的基本操作\u003c/h1\u003e\n\u003cp\u003e1、查看所有的数据库\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-mysql\" data-lang=\"mysql\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eshow\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003edatebases\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e2、创建自己的数据库\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-mysql\" data-lang=\"mysql\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003ecreate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003edatebase\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"err\"\u003e数据库名字\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pr","title":"MySQL的基本操作"},{"content":"","permalink":"http://localhost:1313/java/%E6%B5%8B%E8%AF%95%E7%94%A8/","summary":"","title":"测试"},{"content":"这里就可以写一些关于的相关信息了。gt\n","permalink":"http://localhost:1313/about/","summary":"about","title":"关于"}]