<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Java集合复习 | phjhq&#39;s Blog</title>
<meta name="keywords" content="Java基础, 集合">
<meta name="description" content="java集合简介
一、集合基本的关系结构
Collection 接口的接口 对象的集合（单列集合）">
<meta name="author" content="phjhq">
<link rel="canonical" href="http://localhost:1313/posts/java%E9%9B%86%E5%90%88%E5%A4%8D%E4%B9%A0/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.73849ddbacd99e7f7f65fef830da533e08a3f4b2fad9ce732c65c06701f1000b.css" integrity="sha256-c4Sd26zZnn9/Zf74MNpTPgij9LL62c5zLGXAZwHxAAs=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.png">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon.png">
<link rel="apple-touch-icon" href="http://localhost:1313/favicon.png">
<link rel="mask-icon" href="http://localhost:1313/favicon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/java%E9%9B%86%E5%90%88%E5%A4%8D%E4%B9%A0/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap"
  rel="stylesheet">

<script type="text/javascript" async
  src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
        processEscapes: true,
        processEnvironments: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        TeX: {
          equationNumbers: { autoNumber: "AMS" },
          extensions: ["AMSmath.js", "AMSsymbols.js"]
        }
      }
    });

    MathJax.Hub.Queue(function () {
      
      
      
      var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

<style>
  code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
  }
</style><meta property="og:title" content="Java集合复习" />
<meta property="og:description" content="java集合简介
一、集合基本的关系结构
Collection 接口的接口 对象的集合（单列集合）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/java%E9%9B%86%E5%90%88%E5%A4%8D%E4%B9%A0/" />
<meta property="og:image" content="https://i.postimg.cc/7hwBy7VS/calcr.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-09-11T13:57:35+08:00" />
<meta property="article:modified_time" content="2024-09-11T13:57:35+08:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://i.postimg.cc/7hwBy7VS/calcr.png" />
<meta name="twitter:title" content="Java集合复习"/>
<meta name="twitter:description" content="java集合简介
一、集合基本的关系结构
Collection 接口的接口 对象的集合（单列集合）"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Java集合复习",
      "item": "http://localhost:1313/posts/java%E9%9B%86%E5%90%88%E5%A4%8D%E4%B9%A0/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java集合复习",
  "name": "Java集合复习",
  "description": "java集合简介 一、集合基本的关系结构 Collection 接口的接口 对象的集合（单列集合）\n",
  "keywords": [
    "Java基础", "集合"
  ],
  "articleBody": "java集合简介 一、集合基本的关系结构 Collection 接口的接口 对象的集合（单列集合）\nList 接口：元素按进入先后有序保存，可重复 LinkedList 接口实现类， 链表， 插入删除， 没有同步， 线程不安全 ArrayList 接口实现类， 数组， 随机访问， 没有同步， 线程不安全 Vector 接口实现类 数组， 同步， 线程安全 Stack 是Vector类的实现类 Set 接口： 仅接收一次，不可重复，并做内部排序 HashSet 使用hash表（数组）存储元素 LinkedHashSet 链表维护元素的插入次序 TreeSet 底层实现为二叉树，元素排好序 Map 接口 键值对的集合 （双列集合）\nHashtable 接口实现类， 同步， 线程安全 HashMap 接口实现类 ，没有同步， 线程不安全 LinkedHashMap 双向链表和哈希表实现 WeakHashMap TreeMap 红黑树对所有的key进行排序 IdentifyHashMap 二、Collection接口及方法 2.1 添加 （1）add(E obj)：添加元素对象到当前集合中\n（2）addAll(Collection other)：添加other集合中的所有元素对象到当前集合中，即this = this ∪ other\n2.2 判断 （3）int size()：获取当前集合中实际存储的元素个数\n（4）boolean isEmpty()：判断当前集合是否为空集合\n（5）boolean contains(Object obj)：判断当前集合中是否存在一个与obj对象equals返回true的元素\n（6）boolean containsAll(Collection coll)：判断coll集合中的元素是否在当前集合中都存在。即coll集合是否是当前集合的“子集”\n（7）boolean equals(Object obj)：判断当前集合与obj是否相等\n2.3 删除 （8）void clear()：清空集合元素\n（9） boolean remove(Object obj) ：从当前集合中删除第一个找到的与obj对象equals返回true的元素。\n（10）boolean removeAll(Collection coll)：从当前集合中删除所有与coll集合中相同的元素。即this = this - this ∩ coll （11）boolean retainAll(Collection coll)：从当前集合中删除两个集合中不同的元素，使得当前集合仅保留与coll集合中的元素相同的元素，即当前集合中仅保留两个集合的交集，即this = this ∩ coll；\n2.4其他 （12）Object[] toArray()：返回包含当前集合中所有元素的数组\n（13）hashCode()：获取集合对象的哈希值\n（14）iterator()：返回迭代器对象，用于集合遍历\n三、List集合 3.1 List接口特点 List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。\nJDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。\n3.2 List接口方法 List除了从Collection集合继承的方法外，List 集合里添加了一些根据索引来操作集合元素的方法。\n插入元素 void add(int index,Object ele); 在哦index位置插入ele元素 boolean add(int index ,Collection eles);从index位置开始将eles中的所有元素添加进来 获取元素 Object get(int inedx);获取指定index位置的元素 List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合 获取元素索引 int indexOf(Object obj):返回obj在集合中首次出现的位置 int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置 删除和替换元素 Object remove(int index):移除指定index位置的元素，并返回此元素 Object set(int index, Object ele):设置指定index位置的元素为ele 3.3 List接口主要实现类：ArrayList ArrayList 是 List 接口的主要实现类 本质上，ArrayList是对象引用的一个”变长”数组 Arrays.asList(…) 方法返回的 List 集合，既不是 ArrayList 实例，也不是 Vector 实例。 Arrays.asList(…) 返回值是一个固定长度的 List 集合 3.4 List的实现类之二：LinkedList 对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高。这是由底层采用链表（双向链表）结构存储数据决定的。 特有方法 void addFirst(Object obj) void addLast(Object obj) Object getFirst() Object getLast() Object removeFirst() Object removeLast() 3.5 List的实现类之三：Vector Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的。 在各种List中，最好把ArrayList作为默认选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用。 四、Set集合 4.1 Set接口概述 Set接口是Collection的子接口，Set接口相较于Collection接口没有提供额外的方法 Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个 Set 集合中，则添加操作失败。 Set集合支持的遍历方式和Collection集合一样：foreach和Iterator。 Set的常用实现类有：HashSet、TreeSet、LinkedHashSet。 4.2 Set主要实现类：HashSet HashSet 是 Set 接口的主要实现类，大多数时候使用 Set 集合时都使用这个实现类。\nHashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存储、查找、删除性能。\nHashSet 具有以下特点：\n不能保证元素的排列顺序 HashSet 不是线程安全的 集合元素可以是 null HashSet 集合判断两个元素相等的标准：两个对象通过 hashCode() 方法得到的哈希值相等，并且两个对象的 equals() 方法返回值为true。\n对于存放在Set容器中的对象，对应的类一定要重写hashCode()和equals(Object obj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”。\nHashSet集合中元素的无序性，不等同于随机性。这里的无序性与元素的添加位置有关。具体来说：我们在添加每一个元素到数组中时，具体的存储位置是由元素的hashCode()调用后返回的hash值决定的。导致在数组中每个元素不是依次紧密存放的，表现出一定的无序性。\n4.3 Set实现类之二：LinkedHashSet LinkedHashSet 是 HashSet 的子类，不允许集合元素重复。\nLinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以添加顺序保存的。\nLinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。\n4.4 Set实现类之三：TreeSet TreeSet 是 SortedSet 接口的实现类，TreeSet 可以按照添加的元素的指定的属性的大小顺序进行遍历。 TreeSet底层使用红黑树结构存储数据 五 Map接口 现实生活与开发中，我们常会看到这样的一类集合：用户ID与账户信息、学生姓名与考试成绩、IP地址与主机名等，这种一一对应的关系，就称作映射。Java提供了专门的集合框架用来存储这种映射关系的对象，即java.util.Map接口。\n5.1 Map接口概述 Map与Collection并列存在。用于保存具有映射关系的数据：key-value\nCollection集合称为单列集合，元素是孤立存在的。 Map集合称为双列集合，元素是成对存在的。 Map 中的 key 和 value 都可以是任何引用类型的数据。但常用String类作为Map的“键”。\nMap接口的常用实现类：HashMap、LinkedHashMap、TreeMap和``Properties。其中，HashMap是 Map 接口使用频率最高`的实现类。\n5.2 Map接口的常用方法 添加、修改操作： Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中 void putAll(Map m):将m中的所有key-value对存放到当前map中 删除操作： Object remove(Object key)：移除指定key的key-value对，并返回value void clear()：清空当前map中的所有数据 元素查询的操作： Object get(Object key)：获取指定key对应的value boolean containsKey(Object key)：是否包含指定的key boolean containsValue(Object value)：是否包含指定的value int size()：返回map中key-value对的个数 boolean isEmpty()：判断当前map是否为空 boolean equals(Object obj)：判断当前map和参数对象obj是否相等 元视图操作的方法： Set keySet()：返回所有key构成的Set集合 Collection values()：返回所有value构成的Collection集合 Set entrySet()：返回所有key-value对构成的Set集合 5.3 Map的主要实现类：HashMap 5.3.1 HashMap概述 HashMap是 Map 接口使用频率最高的实现类。 HashMap是线程不安全的。允许添加 null 键和 null 值。 存储数据采用的哈希表结构，底层使用一维数组+单向链表+红黑树进行key-value数据的存储。与HashSet一样，元素的存取顺序不能保证一致。 HashMap 判断两个key相等的标准是：两个 key 的hashCode值相等，通过 equals() 方法返回 true。 HashMap 判断两个value相等的标准是：两个 value 通过 equals() 方法返回 true。 5.4 Map实现类之二：LinkedHashMap LinkedHashMap 是 HashMap 的子类 存储数据采用的哈希表结构+链表结构，在HashMap存储结构的基础上，使用了一对双向链表来记录添加元素的先后顺序，可以保证遍历元素时，与添加的顺序一致。 通过哈希表结构可以保证键的唯一、不重复，需要键所在类重写hashCode()方法、equals()方法。 5.5 Map实现类之三：TreeMap TreeMap存储 key-value 对时，需要根据 key-value 对进行排序。TreeMap 可以保证所有的 key-value 对处于有序状态。 TreeSet底层使用红黑树结构存储数据 TreeMap 的 Key 的排序： 自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException 定制排序：创建 TreeMap 时，构造器传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现 Comparable 接口 TreeMap判断两个key相等的标准：两个key通过compareTo()方法或者compare()方法返回0。 5.6 Map实现类之四：Hashtable Hashtable是Map接口的古老实现类，JDK1.0就提供了。不同于HashMap，Hashtable是线程安全的。 Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构（数组+单向链表），查询速度快。 与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序 Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。 与HashMap不同，Hashtable 不允许使用 null 作为 key 或 value。 5.7 Map实现类之五：Properties Properties 类是 Hashtable 的子类，该对象用于处理属性文件\n由于属性文件里的 key、value 都是字符串类型，所以 Properties 中要求 key 和 value 都是字符串类型\n存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法\n",
  "wordCount" : "4232",
  "inLanguage": "zh",
  "image": "https://i.postimg.cc/7hwBy7VS/calcr.png","datePublished": "2024-09-11T13:57:35+08:00",
  "dateModified": "2024-09-11T13:57:35+08:00",
  "author":{
    "@type": "Person",
    "name": "phjhq"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/java%E9%9B%86%E5%90%88%E5%A4%8D%E4%B9%A0/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "phjhq's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.png"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="phjhq&#39;s Blog (Alt + H)">phjhq&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="首页">
                    <span>首页</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Java集合复习
    </h1>
    <div class="post-meta"><span title='2024-09-11 13:57:35 +0800 CST'>2024-09-11</span>&nbsp;·&nbsp;9 分钟&nbsp;·&nbsp;phjhq

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#java%e9%9b%86%e5%90%88%e7%ae%80%e4%bb%8b" aria-label="java集合简介">java集合简介</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80%e9%9b%86%e5%90%88%e5%9f%ba%e6%9c%ac%e7%9a%84%e5%85%b3%e7%b3%bb%e7%bb%93%e6%9e%84" aria-label="一、集合基本的关系结构">一、集合基本的关系结构</a></li>
                <li>
                    <a href="#%e4%ba%8ccollection%e6%8e%a5%e5%8f%a3%e5%8f%8a%e6%96%b9%e6%b3%95" aria-label="二、Collection接口及方法">二、Collection接口及方法</a><ul>
                        
                <li>
                    <a href="#21-%e6%b7%bb%e5%8a%a0" aria-label="2.1 添加">2.1 添加</a></li>
                <li>
                    <a href="#22-%e5%88%a4%e6%96%ad" aria-label="2.2 判断">2.2 判断</a></li>
                <li>
                    <a href="#23-%e5%88%a0%e9%99%a4" aria-label="2.3 删除">2.3 删除</a></li>
                <li>
                    <a href="#24%e5%85%b6%e4%bb%96" aria-label="2.4其他">2.4其他</a></li>
                <li>
                    <a href="#%e4%b8%89list%e9%9b%86%e5%90%88" aria-label="三、List集合">三、List集合</a><ul>
                        
                <li>
                    <a href="#31-list%e6%8e%a5%e5%8f%a3%e7%89%b9%e7%82%b9" aria-label="3.1 List接口特点">3.1 List接口特点</a></li>
                <li>
                    <a href="#32-list%e6%8e%a5%e5%8f%a3%e6%96%b9%e6%b3%95" aria-label="3.2 List接口方法">3.2 List接口方法</a></li>
                <li>
                    <a href="#33-list%e6%8e%a5%e5%8f%a3%e4%b8%bb%e8%a6%81%e5%ae%9e%e7%8e%b0%e7%b1%bbarraylist" aria-label="3.3 List接口主要实现类：ArrayList">3.3 List接口主要实现类：ArrayList</a></li>
                <li>
                    <a href="#34-list%e7%9a%84%e5%ae%9e%e7%8e%b0%e7%b1%bb%e4%b9%8b%e4%ba%8clinkedlist" aria-label="3.4 List的实现类之二：LinkedList">3.4 List的实现类之二：LinkedList</a></li>
                <li>
                    <a href="#35-list%e7%9a%84%e5%ae%9e%e7%8e%b0%e7%b1%bb%e4%b9%8b%e4%b8%89vector" aria-label="3.5 List的实现类之三：Vector">3.5 List的实现类之三：Vector</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%9b%9bset%e9%9b%86%e5%90%88" aria-label="四、Set集合">四、Set集合</a><ul>
                        
                <li>
                    <a href="#41-set%e6%8e%a5%e5%8f%a3%e6%a6%82%e8%bf%b0" aria-label="4.1 Set接口概述">4.1 Set接口概述</a></li>
                <li>
                    <a href="#42-set%e4%b8%bb%e8%a6%81%e5%ae%9e%e7%8e%b0%e7%b1%bbhashset" aria-label="4.2 Set主要实现类：HashSet">4.2 Set主要实现类：HashSet</a></li>
                <li>
                    <a href="#43-set%e5%ae%9e%e7%8e%b0%e7%b1%bb%e4%b9%8b%e4%ba%8clinkedhashset" aria-label="4.3 Set实现类之二：LinkedHashSet">4.3 Set实现类之二：LinkedHashSet</a></li>
                <li>
                    <a href="#44-set%e5%ae%9e%e7%8e%b0%e7%b1%bb%e4%b9%8b%e4%b8%89treeset" aria-label="4.4 Set实现类之三：TreeSet">4.4 Set实现类之三：TreeSet</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e4%ba%94-map%e6%8e%a5%e5%8f%a3" aria-label="五 Map接口">五 Map接口</a><ul>
                        
                <li>
                    <a href="#51-map%e6%8e%a5%e5%8f%a3%e6%a6%82%e8%bf%b0" aria-label="5.1 Map接口概述">5.1 Map接口概述</a></li>
                <li>
                    <a href="#52-map%e6%8e%a5%e5%8f%a3%e7%9a%84%e5%b8%b8%e7%94%a8%e6%96%b9%e6%b3%95" aria-label="5.2 Map接口的常用方法">5.2 Map接口的常用方法</a></li>
                <li>
                    <a href="#53-map%e7%9a%84%e4%b8%bb%e8%a6%81%e5%ae%9e%e7%8e%b0%e7%b1%bbhashmap" aria-label="5.3 Map的主要实现类：HashMap">5.3 Map的主要实现类：HashMap</a><ul>
                        
                <li>
                    <a href="#531-hashmap%e6%a6%82%e8%bf%b0" aria-label="5.3.1 HashMap概述">5.3.1 HashMap概述</a></li></ul>
                </li>
                <li>
                    <a href="#54-map%e5%ae%9e%e7%8e%b0%e7%b1%bb%e4%b9%8b%e4%ba%8clinkedhashmap" aria-label="5.4 Map实现类之二：LinkedHashMap">5.4 Map实现类之二：LinkedHashMap</a></li>
                <li>
                    <a href="#55-map%e5%ae%9e%e7%8e%b0%e7%b1%bb%e4%b9%8b%e4%b8%89treemap" aria-label="5.5 Map实现类之三：TreeMap">5.5 Map实现类之三：TreeMap</a></li>
                <li>
                    <a href="#56-map%e5%ae%9e%e7%8e%b0%e7%b1%bb%e4%b9%8b%e5%9b%9bhashtable" aria-label="5.6 Map实现类之四：Hashtable">5.6 Map实现类之四：Hashtable</a></li>
                <li>
                    <a href="#57-map%e5%ae%9e%e7%8e%b0%e7%b1%bb%e4%b9%8b%e4%ba%94properties" aria-label="5.7 Map实现类之五：Properties">5.7 Map实现类之五：Properties</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="java集合简介">java集合简介<a hidden class="anchor" aria-hidden="true" href="#java集合简介">#</a></h1>
<h2 id="一集合基本的关系结构">一、集合基本的关系结构<a hidden class="anchor" aria-hidden="true" href="#一集合基本的关系结构">#</a></h2>
<p>Collection 接口的接口 对象的集合（单列集合）</p>
<ul>
<li>List 接口：元素按进入先后有序保存，可重复
<ul>
<li>LinkedList 接口实现类， 链表， 插入删除， 没有同步， 线程不安全</li>
<li>ArrayList 接口实现类， 数组， 随机访问， 没有同步， 线程不安全</li>
<li>Vector 接口实现类 数组， 同步， 线程安全
<ul>
<li>Stack 是Vector类的实现类</li>
</ul>
</li>
</ul>
</li>
<li>Set 接口： 仅接收一次，不可重复，并做内部排序
<ul>
<li>HashSet 使用hash表（数组）存储元素</li>
<li>LinkedHashSet 链表维护元素的插入次序</li>
<li>TreeSet 底层实现为二叉树，元素排好序</li>
</ul>
</li>
</ul>
<img src="https://i.postimg.cc/V66ZdcmS/image-20220407203244029.png"/>
<p>Map 接口 键值对的集合 （双列集合）</p>
<ul>
<li>Hashtable 接口实现类， 同步， 线程安全</li>
<li>HashMap 接口实现类 ，没有同步， 线程不安全
<ul>
<li>LinkedHashMap 双向链表和哈希表实现</li>
<li>WeakHashMap</li>
</ul>
</li>
<li>TreeMap 红黑树对所有的key进行排序</li>
<li>IdentifyHashMap</li>
</ul>
<img sec="https://i.postimg.cc/hjQ9pNQw/image-20220407203412665.png"/>
<h2 id="二collection接口及方法">二、Collection接口及方法<a hidden class="anchor" aria-hidden="true" href="#二collection接口及方法">#</a></h2>
<h3 id="21-添加">2.1 添加<a hidden class="anchor" aria-hidden="true" href="#21-添加">#</a></h3>
<p>（1）add(E obj)：添加元素对象到当前集合中<br>
（2）addAll(Collection other)：添加other集合中的所有元素对象到当前集合中，即this = this ∪ other</p>
<h3 id="22-判断">2.2 判断<a hidden class="anchor" aria-hidden="true" href="#22-判断">#</a></h3>
<p>（3）int size()：获取当前集合中实际存储的元素个数<br>
（4）boolean isEmpty()：判断当前集合是否为空集合<br>
（5）boolean contains(Object obj)：判断当前集合中是否存在一个与obj对象equals返回true的元素<br>
（6）boolean containsAll(Collection coll)：判断coll集合中的元素是否在当前集合中都存在。即coll集合是否是当前集合的“子集”<br>
（7）boolean equals(Object obj)：判断当前集合与obj是否相等</p>
<h3 id="23-删除">2.3 删除<a hidden class="anchor" aria-hidden="true" href="#23-删除">#</a></h3>
<p>（8）void clear()：清空集合元素<br>
（9） boolean remove(Object obj) ：从当前集合中删除第一个找到的与obj对象equals返回true的元素。<br>
（10）boolean removeAll(Collection coll)：从当前集合中删除所有与coll集合中相同的元素。即this = this - this ∩ coll <br>
（11）boolean retainAll(Collection coll)：从当前集合中删除两个集合中不同的元素，使得当前集合仅保留与coll集合中的元素相同的元素，即当前集合中仅保留两个集合的交集，即this  = this ∩ coll；<br></p>
<h3 id="24其他">2.4其他<a hidden class="anchor" aria-hidden="true" href="#24其他">#</a></h3>
<p>（12）Object[] toArray()：返回包含当前集合中所有元素的数组<br>
（13）hashCode()：获取集合对象的哈希值<br>
（14）iterator()：返回迭代器对象，用于集合遍历<br></p>
<h3 id="三list集合">三、List集合<a hidden class="anchor" aria-hidden="true" href="#三list集合">#</a></h3>
<h4 id="31-list接口特点">3.1 List接口特点<a hidden class="anchor" aria-hidden="true" href="#31-list接口特点">#</a></h4>
<p>List集合类中<code>元素有序</code>、且<code>可重复</code>，集合中的每个元素都有其对应的顺序索引。<br>
JDK API中List接口的实现类常用的有：<code>ArrayList</code>、<code>LinkedList</code>和<code>Vector</code>。</p>
<h4 id="32-list接口方法">3.2 List接口方法<a hidden class="anchor" aria-hidden="true" href="#32-list接口方法">#</a></h4>
<p>List除了从Collection集合继承的方法外，List 集合里添加了一些<code>根据索引</code>来操作集合元素的方法。</p>
<ul>
<li>插入元素
<ul>
<li>void add(int index,Object ele); 在哦index位置插入ele元素</li>
<li>boolean add(int index ,Collection eles);从index位置开始将eles中的所有元素添加进来</li>
</ul>
</li>
<li>获取元素
<ul>
<li>Object get(int inedx);获取指定index位置的元素</li>
<li>List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</li>
</ul>
</li>
<li>获取元素索引
<ul>
<li>int indexOf(Object obj):返回obj在集合中首次出现的位置</li>
<li>int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</li>
</ul>
</li>
<li>删除和替换元素
<ul>
<li>Object remove(int index):移除指定index位置的元素，并返回此元素</li>
<li>Object set(int index, Object ele):设置指定index位置的元素为ele</li>
</ul>
</li>
</ul>
<h4 id="33-list接口主要实现类arraylist">3.3 List接口主要实现类：ArrayList<a hidden class="anchor" aria-hidden="true" href="#33-list接口主要实现类arraylist">#</a></h4>
<ul>
<li>ArrayList 是 List 接口的<code>主要实现类</code></li>
<li>本质上，ArrayList是对象引用的一个”变长”数组</li>
<li>Arrays.asList(…) 方法返回的 List 集合，既不是 ArrayList 实例，也不是 Vector 实例。 Arrays.asList(…) 返回值是一个固定长度的 List 集合</li>
</ul>
<h4 id="34-list的实现类之二linkedlist">3.4 List的实现类之二：LinkedList<a hidden class="anchor" aria-hidden="true" href="#34-list的实现类之二linkedlist">#</a></h4>
<ul>
<li>对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高。这是由底层采用链表（双向链表）结构存储数据决定的。</li>
<li>特有方法
<ul>
<li>void addFirst(Object obj)</li>
<li>void addLast(Object obj)</li>
<li>Object getFirst()</li>
<li>Object getLast()</li>
<li>Object removeFirst()</li>
<li>Object removeLast()</li>
</ul>
</li>
</ul>
<h4 id="35-list的实现类之三vector">3.5 List的实现类之三：Vector<a hidden class="anchor" aria-hidden="true" href="#35-list的实现类之三vector">#</a></h4>
<ul>
<li>Vector 是一个<code>古老</code>的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是<code>线程安全</code>的。</li>
<li>在各种List中，最好把<code>ArrayList作为默认选择</code>。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用。</li>
</ul>
<h3 id="四set集合">四、Set集合<a hidden class="anchor" aria-hidden="true" href="#四set集合">#</a></h3>
<h4 id="41-set接口概述">4.1 Set接口概述<a hidden class="anchor" aria-hidden="true" href="#41-set接口概述">#</a></h4>
<ul>
<li>Set接口是Collection的子接口，Set接口相较于Collection接口没有提供额外的方法</li>
<li>Set 集合<code>不允许包含相同的元素</code>，如果试把两个相同的元素加入同一个 Set 集合中，则添加操作失败。</li>
<li>Set集合支持的遍历方式和Collection集合一样：foreach和Iterator。</li>
<li>Set的常用实现类有：HashSet、TreeSet、LinkedHashSet。</li>
</ul>
<h4 id="42-set主要实现类hashset">4.2 Set主要实现类：HashSet<a hidden class="anchor" aria-hidden="true" href="#42-set主要实现类hashset">#</a></h4>
<ul>
<li>
<p>HashSet 是 Set 接口的主要实现类，大多数时候使用 Set 集合时都使用这个实现类。</p>
</li>
<li>
<p>HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存储、查找、删除性能。</p>
</li>
<li>
<p>HashSet 具有以下<code>特点</code>：</p>
<ul>
<li>不能保证元素的排列顺序</li>
<li>HashSet 不是线程安全的</li>
<li>集合元素可以是 null</li>
</ul>
</li>
<li>
<p>HashSet 集合<code>判断两个元素相等的标准</code>：两个对象通过 <code>hashCode()</code> 方法得到的哈希值相等，并且两个对象的 <code>equals() </code>方法返回值为true。</p>
</li>
<li>
<p>对于存放在Set容器中的对象，<strong>对应的类一定要重写hashCode()和equals(Object obj)方法</strong>，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”。</p>
</li>
<li>
<p>HashSet集合中元素的无序性，不等同于随机性。这里的无序性与元素的添加位置有关。具体来说：我们在添加每一个元素到数组中时，具体的存储位置是由元素的hashCode()调用后返回的hash值决定的。导致在数组中每个元素不是依次紧密存放的，表现出一定的无序性。</p>
</li>
</ul>
<h4 id="43-set实现类之二linkedhashset">4.3 Set实现类之二：LinkedHashSet<a hidden class="anchor" aria-hidden="true" href="#43-set实现类之二linkedhashset">#</a></h4>
<ul>
<li>
<p>LinkedHashSet 是 HashSet 的子类，不允许集合元素重复。</p>
</li>
<li>
<p>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用<code>双向链表</code>维护元素的次序，这使得元素看起来是以<code>添加顺序</code>保存的。</p>
</li>
<li>
<p>LinkedHashSet<code>插入性能略低</code>于 HashSet，但在<code>迭代访问</code> Set 里的全部元素时有很好的性能。</p>
</li>
</ul>
<h4 id="44-set实现类之三treeset">4.4 Set实现类之三：TreeSet<a hidden class="anchor" aria-hidden="true" href="#44-set实现类之三treeset">#</a></h4>
<ul>
<li>TreeSet 是 SortedSet 接口的实现类，TreeSet 可以按照添加的元素的指定的属性的大小顺序进行遍历。</li>
<li>TreeSet底层使用<code>红黑树</code>结构存储数据</li>
</ul>
<h2 id="五-map接口">五 Map接口<a hidden class="anchor" aria-hidden="true" href="#五-map接口">#</a></h2>
<p>现实生活与开发中，我们常会看到这样的一类集合：用户ID与账户信息、学生姓名与考试成绩、IP地址与主机名等，这种一一对应的关系，就称作映射。Java提供了专门的集合框架用来存储这种映射关系的对象，即<code>java.util.Map</code>接口。</p>
<h3 id="51-map接口概述">5.1 Map接口概述<a hidden class="anchor" aria-hidden="true" href="#51-map接口概述">#</a></h3>
<ul>
<li>
<p>Map与Collection并列存在。用于保存具有<code>映射关系</code>的数据：key-value</p>
<ul>
<li><code>Collection</code>集合称为单列集合，元素是孤立存在的。</li>
<li><code>Map</code>集合称为双列集合，元素是成对存在的。</li>
</ul>
</li>
<li>
<p>Map 中的 key 和  value 都可以是任何引用类型的数据。但常用String类作为Map的“键”。</p>
</li>
<li>
<p>Map接口的常用实现类：<code>HashMap</code>、<code>LinkedHashMap</code>、<code>TreeMap</code>和``Properties<code>。其中，HashMap是 Map 接口使用</code>频率最高`的实现类。<br></p>
</li>
</ul>
<img src="https://i.postimg.cc/kGGdw9Td/image-20220409001015034.png" />
<h3 id="52-map接口的常用方法">5.2 Map接口的常用方法<a hidden class="anchor" aria-hidden="true" href="#52-map接口的常用方法">#</a></h3>
<ul>
<li><strong>添加、修改操作：</strong>
<ul>
<li>Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中</li>
<li>void putAll(Map m):将m中的所有key-value对存放到当前map中</li>
</ul>
</li>
<li><strong>删除操作：</strong>
<ul>
<li>Object remove(Object key)：移除指定key的key-value对，并返回value</li>
<li>void clear()：清空当前map中的所有数据</li>
</ul>
</li>
<li><strong>元素查询的操作：</strong>
<ul>
<li>Object get(Object key)：获取指定key对应的value</li>
<li>boolean containsKey(Object key)：是否包含指定的key</li>
<li>boolean containsValue(Object value)：是否包含指定的value</li>
<li>int size()：返回map中key-value对的个数</li>
<li>boolean isEmpty()：判断当前map是否为空</li>
<li>boolean equals(Object obj)：判断当前map和参数对象obj是否相等</li>
</ul>
</li>
<li><strong>元视图操作的方法：</strong>
<ul>
<li>Set keySet()：返回所有key构成的Set集合</li>
<li>Collection values()：返回所有value构成的Collection集合</li>
<li>Set entrySet()：返回所有key-value对构成的Set集合</li>
</ul>
</li>
</ul>
<h3 id="53-map的主要实现类hashmap">5.3 Map的主要实现类：HashMap<a hidden class="anchor" aria-hidden="true" href="#53-map的主要实现类hashmap">#</a></h3>
<h4 id="531-hashmap概述">5.3.1 HashMap概述<a hidden class="anchor" aria-hidden="true" href="#531-hashmap概述">#</a></h4>
<ul>
<li>HashMap是 Map 接口<code>使用频率最高</code>的实现类。</li>
<li>HashMap是<code>线程不安全</code>的。允许添加 null 键和 null 值。</li>
<li>存储数据采用的哈希表结构，底层使用<code>一维数组</code>+<code>单向链表</code>+<code>红黑树</code>进行key-value数据的存储。与HashSet一样，元素的存取顺序不能保证一致。</li>
<li>HashMap <code>判断两个key相等的标准</code>是：两个 key 的hashCode值相等，通过 equals() 方法返回 true。</li>
<li>HashMap <code>判断两个value相等的标准</code>是：两个 value 通过 equals() 方法返回 true。</li>
</ul>
<h3 id="54-map实现类之二linkedhashmap">5.4 Map实现类之二：LinkedHashMap<a hidden class="anchor" aria-hidden="true" href="#54-map实现类之二linkedhashmap">#</a></h3>
<ul>
<li>LinkedHashMap 是 HashMap 的子类</li>
<li>存储数据采用的哈希表结构+链表结构，在HashMap存储结构的基础上，使用了一对<code>双向链表</code>来<code>记录添加元素的先后顺序</code>，可以保证遍历元素时，与添加的顺序一致。</li>
<li>通过哈希表结构可以保证键的唯一、不重复，需要键所在类重写hashCode()方法、equals()方法。</li>
</ul>
<h3 id="55-map实现类之三treemap">5.5 Map实现类之三：TreeMap<a hidden class="anchor" aria-hidden="true" href="#55-map实现类之三treemap">#</a></h3>
<ul>
<li>TreeMap存储 key-value 对时，需要根据 key-value 对进行排序。TreeMap 可以保证所有的 key-value 对处于<code>有序状态</code>。</li>
<li>TreeSet底层使用<code>红黑树</code>结构存储数据</li>
<li>TreeMap 的 Key 的排序：
<ul>
<li><code>自然排序</code>：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException</li>
<li><code>定制排序</code>：创建 TreeMap 时，构造器传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现 Comparable 接口</li>
</ul>
</li>
<li>TreeMap判断<code>两个key相等的标准</code>：两个key通过compareTo()方法或者compare()方法返回0。</li>
</ul>
<h3 id="56-map实现类之四hashtable">5.6 Map实现类之四：Hashtable<a hidden class="anchor" aria-hidden="true" href="#56-map实现类之四hashtable">#</a></h3>
<ul>
<li>Hashtable是Map接口的<code>古老实现类</code>，JDK1.0就提供了。不同于HashMap，Hashtable是线程安全的。</li>
<li>Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构（数组+单向链表），查询速度快。</li>
<li>与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序</li>
<li>Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。</li>
<li>与HashMap不同，Hashtable 不允许使用 null 作为 key 或 value。</li>
</ul>
<h3 id="57-map实现类之五properties">5.7 Map实现类之五：Properties<a hidden class="anchor" aria-hidden="true" href="#57-map实现类之五properties">#</a></h3>
<ul>
<li>
<p>Properties 类是 Hashtable 的子类，该对象用于处理属性文件</p>
</li>
<li>
<p>由于属性文件里的 key、value 都是字符串类型，所以 Properties 中要求 key 和 value 都是字符串类型</p>
</li>
<li>
<p>存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法</p>
</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/java%E5%9F%BA%E7%A1%80/">Java基础</a></li>
      <li><a href="http://localhost:1313/tags/%E9%9B%86%E5%90%88/">集合</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/stop-hyper-v/">
    <span class="title">« 上一页</span>
    <br>
    <span>Stop Hyper V</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/my-first-post/">
    <span class="title">下一页 »</span>
    <br>
    <span>MySQL的基本操作</span>
  </a>
</nav>

  </footer><div id="tw-comment"></div>

<script>
  
  const getStoredTheme = () => localStorage.getItem("pref-theme") === "light" ? "light" : "dark";
  const setGiscusTheme = () => {
    const sendMessage = (message) => {
      const iframe = document.querySelector('iframe.giscus-frame');
      if (iframe) {
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');

      }

    }
    sendMessage({ setConfig: { theme: getStoredTheme() } })

  }

  document.addEventListener("DOMContentLoaded", () => {
    const giscusAttributes = {
      "src": "https://giscus.app/client.js",
      "data-repo": "houjinghao123\/houjinghao123.github.io",
      "data-repo-id": "R_kgDOMvdtTg",
      "data-category": "Announcements",
      "data-category-id": "DIC_kwDOMvdtTs4CiV_q",
      "data-mapping": "pathname",
      "data-strict": "0",
      "data-reactions-enabled": "1",
      "data-emit-metadata": "0",
      "data-input-position": "bottom",
      "data-theme": getStoredTheme(),
      "data-lang": "zh-CN",
      "data-loading": "lazy",
      "crossorigin": "anonymous",
    };

    
    const giscusScript = document.createElement("script");
    Object.entries(giscusAttributes).forEach(
      ([key, value]) => giscusScript.setAttribute(key, value));
    document.querySelector("#tw-comment").appendChild(giscusScript);

    
    const themeSwitcher = document.querySelector("#theme-toggle");
    if (themeSwitcher) {
      themeSwitcher.addEventListener("click", setGiscusTheme);

    }
    const themeFloatSwitcher = document.querySelector("#theme-toggle-float");
    if (themeFloatSwitcher) {
      themeFloatSwitcher.addEventListener("click", setGiscusTheme);

    }

  });
</script>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://houjinghao123.github.io/">©2024 phjhq&rsquo;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>


<script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js"
  integrity="sha512-9ZKhgaFdKlsELap/dGw3Iaz5Bj+Las0XXZiRKYZaN9QArg6FtkD5rULNmNH4rTCTFxjPiBGr3MX8smRADRorDA=="
  crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script>
  var OSName = "unknown";
  var navApp = navigator.userAgent.toLowerCase();
  switch (true) {
    case (navApp.indexOf("win") != -1):
      OSName = "windows";
      break;
    case (navApp.indexOf("mac") != -1):
      OSName = "apple";
      break;
    case (navApp.indexOf("linux") != -1):
      OSName = "linux";
      break;
    case (navApp.indexOf("x11") != -1):
      OSName = "unix";
      break;
  }

  const images = Array.from(document.querySelectorAll(".post-content img"));
  images.forEach(img => {
    mediumZoom(img, {
      margin: 1,    
      scrollOffset: 40,  
      container: null,  
      template: null,  
      
    });
  });

  if (OSName == "windows") {
    document.body.className += ' win11'
  }
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
