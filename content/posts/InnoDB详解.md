+++
title = 'InnoDB详解'
date = 2024-10-02T18:17:59+08:00
categories = ["MySQL"]
tags =["InnoDB"]
+++

## 1、逻辑存储结构
![](https://cdn.nlark.com/yuque/0/2024/png/49057062/1727766135694-2cc9063a-a21b-45b9-ad26-34c9691c6f26.png)

1）表空间

 表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在 8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空 间，用于存储记录、索引等数   据。

![](https://cdn.nlark.com/yuque/0/2024/png/49057062/1727766324137-3f22afbd-feee-4b63-b39e-df1f36ff9286.png)

2）段

 段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段 （Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的 非叶子节点。段用来管理多个Extent（区）。

 3） 区

 区，表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一 个区中一共有64个连续的页。

4）页

 页，是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性， InnoDB 存储引擎每次从磁盘申请 4-5 个区。

5）行

 行，InnoDB 存储引擎数据是按行进行存放的。在行中，默认有两个隐藏字段：

+ Trx_id:每行对某条数据进行改动时，都会把对应的事务id赋值给trx_id隐藏列。
+ Roll_pointer:每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。



## 2、架构
### 2.1概述
 MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发 中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。  ![](https://cdn.nlark.com/yuque/0/2024/png/49057062/1727766719433-86e21b73-518b-4a79-a14f-26582b17a504.png)

### 2.2内存架构
![](https://cdn.nlark.com/yuque/0/2024/png/49057062/1727776209436-78edcc3c-ce80-44b0-ae73-ac7604571602.png)

 在左侧的内存结构中，主要分为这么四大块儿：  Buffer Pool，Change Buffer,Adaptive Hash Index,Log Buffer。

#### Buffer Pool
 InnoDB存储引擎基于磁盘文件存储，访问物理硬盘是在内存中进行访问，速度相差很大，为了尽可能 弥补这两者之间的I/O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁 盘I/O。

 在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及 InnoDB的锁信息等等。

 缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增 删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频 率刷新到磁盘，从而减少磁盘IO，加快处理速度。

 缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：

+ free page:空闲page，未被使用
+ clean page：被使用page，数据没有被修改过。
+ dirty page：脏页，被使用page，数据被修改过，内存中的数据与磁盘的数据产生了不一致。

 在专用服务器上，通常将多达80％的物理内存分配给缓冲池 。参数设置：

```sql
show variables like 'innodb_buffer_pool_size';
```

![](https://cdn.nlark.com/yuque/0/2024/png/49057062/1727776772359-555b5b5c-2497-4703-93b7-92e3f33215cb.png)

****

#### Change Buffer
 Change Buffer，更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page 没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer 中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。

 Change Buffer的意义是什么呢?

![](https://cdn.nlark.com/yuque/0/2024/png/49057062/1727777017493-48aa0270-8f12-4a15-b72a-56f10efa2a48.png)

 与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新 可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了 ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。



#### Adaptive Hash Index
 自适应hash索引，用于优化对Buffer Pool数据的查询。MySQL的innoDB引擎中虽然没有直接支持 hash索引，但是给我们提供了一个功能就是这个自适应hash索引。因为前面我们讲到过，hash索引在 进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需 要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。 InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度， 则建立hash索引，称之为自适应hash索引。

**自适应哈希索引，无需人工干预，是系统根据情况自动完成。**

参数： adaptive_hash_index

#### Log Buffer
 Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log）， 默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事 务，增加日志缓冲区的大小可以节省磁盘 I/O。

参数：

 innodb_log_buffer_size：缓冲区大小

 innodb_flush_log_at_trx_commit：日志刷新到磁盘时机，取值主要包含以下三个：

 1: 日志在每次事务提交时写入并刷新到磁盘，默认值。

 0: 每秒将日志写入并刷新到磁盘一次。

 2: 日志在每次事务提交后写入，并每秒刷新到磁盘一次。

![](https://cdn.nlark.com/yuque/0/2024/png/49057062/1727777756184-1982c62d-8288-4d9c-9bb2-e8e769c0f0d7.png)



### 2.3磁盘结构
 接下来，再来看看InnoDB体系结构的右边部分，也就是磁盘结构：

![](https://cdn.nlark.com/yuque/0/2024/png/49057062/1727777944227-af8f02e8-16b9-4c00-a0f3-79a91aec7667.png)

#### System Tablespace
 系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建 的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等)

 参数：innodb_data_file_path

![](https://cdn.nlark.com/yuque/0/2024/png/49057062/1727778251171-7f547908-f89b-44ba-922b-a60f7294707e.png)

 系统表空间，默认的文件名叫 ibdata1。



#### File-Per-Table Tablespaces
 如果开启了innodb_file_per_table开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索 引 ，并存储在文件系统上的单个数据文件中。

 开关参数：innodb_file_per_table ，该参数默认开启。

![](https://cdn.nlark.com/yuque/0/2024/png/49057062/1727778346938-d2682771-abd6-4317-be93-eae443491bda.png)



#### General Tablespaces
General Tablespaces允许用户将多个表的数据存储在一个共享的表空间文件中。这种方式有以下一些用途和优势：

1.如果有很多小表，使用共享表空间可以帮助减少磁盘上的文件数量，使得文件管理更加简单。

2.当需要将多个表的数据放在同一个物理设备上时，可以使用共享表空间来实现这一需求。

3.在某些情况下，通过将频繁访问的表放在同一个高速存储设备上的共享表空间中，可以提高访问速度。
如果整个应用的多个表都需要一起备份或恢复，共享表空间可以简化这一过程。

 A. 创建表空间

```sql
create tablespace ts_name add datafile 'file_name' enginie =engine_name;
```

![](https://cdn.nlark.com/yuque/0/2024/png/49057062/1727778573996-ef829332-f594-4ba3-b952-6b560c82075e.png)

 B. 创建表时指定表空间

```sql
CREATE TABLE xxx ... TABLESPACE ts_name;
```

![](https://cdn.nlark.com/yuque/0/2024/png/49057062/1727778713471-28b0b393-0466-4e2a-957f-408b3eb381c9.png)

####  Undo Tablespaces
 撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储 undo log日志。

####  Temporary Tablespaces
 InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。

####  Doublewrite Buffer Files
 双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件 中，便于系统异常时恢复数据。

####  Redo Log
 重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所 有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。



### 2.4后台线程
 前面我们介绍了InnoDB的内存结构，以及磁盘结构，那么内存中我们所更新的数据，又是如何到磁盘 中的呢？ 此时，就涉及到一组后台线程，接下来，就来介绍一些InnoDB中涉及到的后台线程。

 在InnoDB的后台线程中，分为4类，分别是：Master Thread 、IO Thread、Purge Thread、 Page Cleaner Thread。

####  Master Thread
 核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性， 还包括脏页的刷新、合并插入缓存、undo页的回收 。

####  IO Thread
 在InnoDB存储引擎中大量使用了AIO来处理IO请求, 这样可以极大地提高数据库的性能，而IO Thread主要负责这些IO请求的回调。



| 线程类型             | 默认个数 | 职责                         |
| -------------------- | -------- | ---------------------------- |
| Read thread          | 4        | 负责读操作                   |
| Write thread         | 4        | 负责写操作                   |
| Log thread           | 1        | 负责将日志缓冲区刷新到磁盘   |
| Insert buffer thread | 1        | 负责将写缓冲区内容刷新到磁盘 |


```sql
show engine innodb status \G;
```

![](https://cdn.nlark.com/yuque/0/2024/png/49057062/1727779549695-0cb9d842-e7e0-4126-9413-e2f60fed5b61.png)

####  Purge Thread
 主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回收。

####  Page Cleaner Thread
 协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻塞。





## 3、事务原理
### 3.1事务基础
#### 什么是事务
 事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。

#### 特性
+ 原子性（Atomicity）： 事务是不可分割的最小操作单元，要么全部成功，要么全部失败。
+ 一致性（Consistency）： 事务完成时，必须使所有的数据都保持一致状态。
+ 隔离性（Isolation）： 数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环 境下运行。
+ 持久性（Durabiity）：  事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。

 而对于这四大特性，实际上分为两个部分。 其中的原子性、一致性、持久化，实际上是由InnoDB中的 两份日志来保证的，一份是redo log日志，一份是undo log日志。 而持久性是通过数据库的锁， 加上MVCC来保证的。  ![](https://cdn.nlark.com/yuque/0/2024/png/49057062/1727779914377-7cf8df0f-ca5e-48dd-afd9-d9afcd236d64.png)

### 3.2redo log(发生错误时, 进行数据恢复使用)


 重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。

 该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用 于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。

**没有redo log的情况下 **

![](https://cdn.nlark.com/yuque/0/2024/png/49057062/1727860544274-cd3ebbb1-c636-4fca-9a79-69e0dfc1c2d7.png)

数据先是在缓冲池中进行增删改查等操作，如果没有就会到磁盘中进行操作，如果在缓冲池中能直接找到就直接在内存中进行修改，此时缓冲池中的数据页就是脏页，这些脏页也会在特定的时机刷新到磁盘中， 假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却 没有持久化下来，这就出现问题了，没有保证事务的持久性。

 **在InnoDB中提供了一份日志 redo log**

![](https://cdn.nlark.com/yuque/0/2024/png/49057062/1727860900331-460b659d-f5a0-4b0d-a16a-1bd498b5025f.png)

 有了redolog之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redo log buffer中。在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。 过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了事务的持久性。 而如果脏页成功刷新到磁盘或者涉及到的数据已经落盘，此时redolog就没有作用了，就可以删除了，所以存在的两个redolog文件是循环写的。



 那为什么每一次提交事务，要刷新redo log 到磁盘中呢，而不是直接将buffer pool中的脏页刷新 到磁盘呢 ?

 因为在业务操作中，我们操作数据一般都是 `随机读写磁盘`的，而不是 `顺序读写磁盘`。 而redo log在 往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这 种先写日志的方式，称之为 WAL（Write-Ahead Logging）。

### 3.3undo log(事务回滚时使用+MVCC)
 回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和 MVCC(多版本并发控制) 。

+ Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些 日志可能还用于MVCC。
+ Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含1024个undo log segment。

### 3.4MVCC
#### 3.4.1什么是MVCC
全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本， 使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。

#### 3.4.2MVCC相关概念
+ **当前读**

     读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。使用排他锁和共享锁就是一种当前锁。

![](https://cdn.nlark.com/yuque/0/2024/png/49057062/1727862475695-0249750e-cecb-4dbc-a07e-3c0e6b1395fa.png)

在测试中我们可以看到，即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内 容，因为在查询语句后面加上了 lock in share mode 共享锁，此时是当前读操作。当然，当我们 加排他锁的时候，也是当前读操作。

+  **快照读**

简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据， 不加锁，是非阻塞读。

![](https://cdn.nlark.com/yuque/0/2024/png/49057062/1727862823082-d6eeaa7f-39bf-4bd1-994f-d16ace0404bf.png)

 • Read Committed：每次select，都生成一个快照读。

• Repeatable Read：开启事务后第一个select语句才是快照读的地方。

 • Serializable：快照读会退化为当前读。



#### 3.4.3MVCC的组成之隐藏字段
当我们创建了一张表时，我们在查看表结构的时候，就可以显式的看到自己定义的字段。 实际上除了自己定义的字段以外，InnoDB还会自动的给我们添加三个隐藏字段及其含义分别是：

| 隐藏字段    | 含义                                                                    |
| ----------- | ----------------------------------------------------------------------- |
| DB_TRX_ID   | 最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。          |
| DB_ROLL_PTR | 回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版 本。 |
| DB_ROW_ID   | 隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。                  |


 而上述的前两个字段是肯定会添加的， 是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键， 如果有主键，则不会添加该隐藏字段。

#### 3.4.4MVCC的组成之undo log
+ **介绍**

 回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。 当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。 而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即 被删除。

+ **版本链**

 有一张表原始数据为：

![](https://cdn.nlark.com/yuque/0/2024/png/49057062/1727863248547-db524f48-ae9c-4914-a240-efea0623a9fe.png)

> DB_TRX_ID : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是自增的。 DB_ROLL_PTR ： 由于这条数据是才插入的，没有被更新过，所以该字段值为null。
>

 然后，有四个并发事务同时在访问这张表。

![](https://cdn.nlark.com/yuque/0/2024/png/49057062/1727863293946-142a70ee-271f-40fa-9cea-7aaff21b4828.png)![](https://cdn.nlark.com/yuque/0/2024/png/49057062/1727863384695-395626ff-a372-4077-bb0f-251d99ec6a00.png)

上面的四个事务总共进行了三次修改，所以在undo log就记录了三条数据。

>  最终我们发现，不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条 记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。
>

#### 3.4.5MVCC的组成之ReadView
 ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务 （未提交的）id。

 ReadView中包含了四个核心字段：

| 字段           | 含义                                                 |
| -------------- | ---------------------------------------------------- |
| m_ids          | 当前活跃的事务ID集合                                 |
| min_trx_id     | 最小活跃事务ID                                       |
| max_trx_id     | 预分配事务ID，当前最大事务ID+1（因为事务ID是自增的） |
| creator_trx_id | ReadView创建者的事务ID                               |


 而在readview中就规定了 `版本链数据的访问规则`： trx_id 代表当前undolog版本链对应事务ID

| 条件                              | 是否可以访问                               | 说明                                          |
| --------------------------------- | ------------------------------------------ | --------------------------------------------- |
| trx_id == creator_trx_id          | 可以访问该版本                             | 成立，说明数据是当前这个事 务更改的。         |
| trx_id < min_trx_id               | 可以访问该版本                             | 成立，说明数据已经提交了。                    |
| trx_id > max_trx_id               | 不可以访问该版本                           | 成立，说明该事务是在 ReadView生成后才开启  。 |
| min_trx_id <= trx_id <=max_trx_id | 如果trx_id不在m_ids中， 是可以访问该版本的 | 成立，说明数据已经提交                        |


 不同的隔离级别，生成ReadView的时机不同：

+  READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。
+  REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。

#### ReadView不同隔离级别分析
##### RC隔离级别
 RC隔离级别下，在事务中每一次执行快照读时生成ReadView。

 我们就来分析事务5中，两次快照读读取数据，是如何获取数据的?

 在事务5中，查询了两次id为30的记录，由于隔离级别为Read Committed，所以每一次进行快照读 都会生成一个ReadView，那么两次生成的ReadView如下。

![](https://cdn.nlark.com/yuque/0/2024/png/49057062/1727863952185-a54507ac-61ad-4b47-bb15-a49db7659965.png)



 那么这两次快照读在获取数据时，就需要根据所生成的ReadView以及ReadView的版本链访问规则， 到undolog版本链中匹配数据，最终决定此次快照读返回的数据。

先来看第一次快照读具体的读取过程：

![](https://cdn.nlark.com/yuque/0/2024/png/49057062/1727864056918-2ef29022-6822-4963-854e-06d18fa9b77d.png)

 在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：



##### RR隔离级别
 RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 而RR 是可 重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。

